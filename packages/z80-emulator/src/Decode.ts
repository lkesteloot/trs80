// Do not modify. This file was generated by GenerateOpcodes.ts.

import {Z80} from "./Z80";
import {toHex, inc8, inc16, dec8, dec16, add8, add16, sub8, sub16, word, hi, lo, Flag, signedByte} from "z80-base";

type OpcodeFunc = (z80: Z80) => void;

// Tables for computing flags after an operation.
const halfCarryAddTable = [0, Flag.H, Flag.H, Flag.H, 0, 0, 0, Flag.H];
const halfCarrySubTable = [0, 0, Flag.H, 0, Flag.H, 0, Flag.H, Flag.H];
const overflowAddTable = [0, 0, 0, Flag.V, Flag.V, 0, 0, 0];
const overflowSubTable = [0, Flag.V, 0, 0, 0, 0, Flag.V, 0];

const decodeMapBASE = new Map<number, OpcodeFunc>();
decodeMapBASE.set(0x00, (z80: Z80) => { // nop
});
decodeMapBASE.set(0x01, (z80: Z80) => { // ld bc,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x02, (z80: Z80) => { // ld (bc),a
    let value: number;
    value = z80.regs.a;
    z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.bc));
    z80.writeByte(z80.regs.bc, value);
});
decodeMapBASE.set(0x03, (z80: Z80) => { // inc bc
    let value: number;
    value = z80.regs.bc;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x04, (z80: Z80) => { // inc b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.b = value;
});
decodeMapBASE.set(0x05, (z80: Z80) => { // dec b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.b = value;
});
decodeMapBASE.set(0x06, (z80: Z80) => { // ld b,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.b = value;
});
decodeMapBASE.set(0x07, (z80: Z80) => { // rlca
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a >> 7) | (z80.regs.a << 1)) & 0xFF;
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | (z80.regs.a & (Flag.X3 | Flag.X5)) | ((oldA & 0x80) !== 0 ? Flag.C : 0);
});
decodeMapBASE.set(0x08, (z80: Z80) => { // ex af,af'
    const rightValue = z80.regs.afPrime;
    z80.regs.afPrime = z80.regs.af;
    z80.regs.af = rightValue;
});
decodeMapBASE.set(0x09, (z80: Z80) => { // add hl,bc
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x0A, (z80: Z80) => { // ld a,(bc)
    let value: number;
    z80.regs.memptr = inc16(z80.regs.bc);
    value = z80.readByte(z80.regs.bc);
    z80.regs.a = value;
});
decodeMapBASE.set(0x0B, (z80: Z80) => { // dec bc
    let value: number;
    value = z80.regs.bc;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x0C, (z80: Z80) => { // inc c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.c = value;
});
decodeMapBASE.set(0x0D, (z80: Z80) => { // dec c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.c = value;
});
decodeMapBASE.set(0x0E, (z80: Z80) => { // ld c,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.c = value;
});
decodeMapBASE.set(0x0F, (z80: Z80) => { // rrca
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a >> 1) | (z80.regs.a << 7)) & 0xFF;
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | (z80.regs.a & (Flag.X3 | Flag.X5)) | ((oldA & 0x01) !== 0 ? Flag.C : 0);
});
decodeMapBASE.set(0x10, (z80: Z80) => { // djnz offset
    z80.incTStateCount(1);
    z80.regs.b = dec8(z80.regs.b);
    if (z80.regs.b !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
        z80.regs.pc = inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    } else {
        z80.incTStateCount(3);
        z80.regs.pc = inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x11, (z80: Z80) => { // ld de,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.de = value;
});
decodeMapBASE.set(0x12, (z80: Z80) => { // ld (de),a
    let value: number;
    value = z80.regs.a;
    z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.de));
    z80.writeByte(z80.regs.de, value);
});
decodeMapBASE.set(0x13, (z80: Z80) => { // inc de
    let value: number;
    value = z80.regs.de;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.de = value;
});
decodeMapBASE.set(0x14, (z80: Z80) => { // inc d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.d = value;
});
decodeMapBASE.set(0x15, (z80: Z80) => { // dec d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.d = value;
});
decodeMapBASE.set(0x16, (z80: Z80) => { // ld d,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.d = value;
});
decodeMapBASE.set(0x17, (z80: Z80) => { // rla
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a << 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x01 : 0)) & 0xFF;
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | (z80.regs.a & (Flag.X3 | Flag.X5)) | ((oldA & 0x80) !== 0 ? Flag.C : 0);
});
decodeMapBASE.set(0x18, (z80: Z80) => { // jr offset
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0x19, (z80: Z80) => { // add hl,de
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x1A, (z80: Z80) => { // ld a,(de)
    let value: number;
    z80.regs.memptr = inc16(z80.regs.de);
    value = z80.readByte(z80.regs.de);
    z80.regs.a = value;
});
decodeMapBASE.set(0x1B, (z80: Z80) => { // dec de
    let value: number;
    value = z80.regs.de;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.de = value;
});
decodeMapBASE.set(0x1C, (z80: Z80) => { // inc e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.e = value;
});
decodeMapBASE.set(0x1D, (z80: Z80) => { // dec e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.e = value;
});
decodeMapBASE.set(0x1E, (z80: Z80) => { // ld e,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.e = value;
});
decodeMapBASE.set(0x1F, (z80: Z80) => { // rra
    const oldA = z80.regs.a;
    z80.regs.a = (z80.regs.a >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | (z80.regs.a & (Flag.X3 | Flag.X5)) | ((oldA & 0x01) !== 0 ? Flag.C : 0);
});
decodeMapBASE.set(0x20, (z80: Z80) => { // jr nz,offset
    if ((z80.regs.f & Flag.Z) === 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
        z80.regs.pc = inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    } else {
        z80.incTStateCount(3);
        z80.regs.pc = inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x21, (z80: Z80) => { // ld hl,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x22, (z80: Z80) => { // ld (nnnn),hl
    let value: number;
    value = z80.regs.hl;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapBASE.set(0x23, (z80: Z80) => { // inc hl
    let value: number;
    value = z80.regs.hl;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x24, (z80: Z80) => { // inc h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.h = value;
});
decodeMapBASE.set(0x25, (z80: Z80) => { // dec h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.h = value;
});
decodeMapBASE.set(0x26, (z80: Z80) => { // ld h,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.h = value;
});
decodeMapBASE.set(0x27, (z80: Z80) => { // daa
    let value = 0;
    let carry = z80.regs.f & Flag.C;
    if ((z80.regs.f & Flag.H) !== 0 || ((z80.regs.a & 0x0F) > 9)) {
        value = 6; // Skip over hex digits in lower nybble.
    }
    if (carry !== 0 || z80.regs.a > 0x99) {
        value |= 0x60; // Skip over hex digits in upper nybble.
    }
    if (z80.regs.a > 0x99) {
        carry = Flag.C;
    }
    if ((z80.regs.f & Flag.N) !== 0) {
        let result = sub16(z80.regs.a, value);
        const lookup = (((z80.regs.a & 0x88) >> 3) |
                       ((value & 0x88) >> 2) |
                       ((result & 0x88) >> 1)) & 0xFF;
        z80.regs.a = result & 0xFF;
        z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
    } else {
        let result = add16(z80.regs.a, value);
        const lookup = (((z80.regs.a & 0x88) >> 3) |
                       ((value & 0x88) >> 2) |
                       ((result & 0x88) >> 1)) & 0xFF;
        z80.regs.a = result & 0xFF;
        z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
    }
    z80.regs.f = (z80.regs.f & ~(Flag.C | Flag.P)) | carry | z80.parityTable[z80.regs.a];
});
decodeMapBASE.set(0x28, (z80: Z80) => { // jr z,offset
    if ((z80.regs.f & Flag.Z) !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
        z80.regs.pc = inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    } else {
        z80.incTStateCount(3);
        z80.regs.pc = inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x29, (z80: Z80) => { // add hl,hl
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x2A, (z80: Z80) => { // ld hl,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x2B, (z80: Z80) => { // dec hl
    let value: number;
    value = z80.regs.hl;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x2C, (z80: Z80) => { // inc l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.l = value;
});
decodeMapBASE.set(0x2D, (z80: Z80) => { // dec l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.l = value;
});
decodeMapBASE.set(0x2E, (z80: Z80) => { // ld l,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.l = value;
});
decodeMapBASE.set(0x2F, (z80: Z80) => { // cpl
    z80.regs.a ^= 0xFF;
    z80.regs.f = (z80.regs.f & (Flag.C | Flag.P | Flag.Z | Flag.S)) | (z80.regs.a & (Flag.X3 | Flag.X5)) | Flag.N | Flag.H;
});
decodeMapBASE.set(0x30, (z80: Z80) => { // jr nc,offset
    if ((z80.regs.f & Flag.C) === 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
        z80.regs.pc = inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    } else {
        z80.incTStateCount(3);
        z80.regs.pc = inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x31, (z80: Z80) => { // ld sp,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x32, (z80: Z80) => { // ld (nnnn),a
    let value: number;
    value = z80.regs.a;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.regs.a, inc16(value));
    z80.writeByte(value, z80.regs.a);
});
decodeMapBASE.set(0x33, (z80: Z80) => { // inc sp
    let value: number;
    value = z80.regs.sp;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x34, (z80: Z80) => { // inc (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x35, (z80: Z80) => { // dec (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x36, (z80: Z80) => { // ld (hl),nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x37, (z80: Z80) => { // scf
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | Flag.C | (z80.regs.a & (Flag.X3 | Flag.X5));
});
decodeMapBASE.set(0x38, (z80: Z80) => { // jr c,offset
    if ((z80.regs.f & Flag.C) !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, signedByte(offset));
        z80.regs.pc = inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    } else {
        z80.incTStateCount(3);
        z80.regs.pc = inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x39, (z80: Z80) => { // add hl,sp
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x3A, (z80: Z80) => { // ld a,(nnnn)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = inc16(value);
    value = z80.readByte(value);
    z80.regs.a = value;
});
decodeMapBASE.set(0x3B, (z80: Z80) => { // dec sp
    let value: number;
    value = z80.regs.sp;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x3C, (z80: Z80) => { // inc a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.a = value;
});
decodeMapBASE.set(0x3D, (z80: Z80) => { // dec a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.a = value;
});
decodeMapBASE.set(0x3E, (z80: Z80) => { // ld a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.a = value;
});
decodeMapBASE.set(0x3F, (z80: Z80) => { // ccf
    z80.regs.f = (z80.regs.f & (Flag.P | Flag.Z | Flag.S)) | ((z80.regs.f & Flag.C) !== 0 ? Flag.H : Flag.C) | (z80.regs.a & (Flag.X3 | Flag.X5));
});
decodeMapBASE.set(0x40, (z80: Z80) => { // ld b,b
    let value: number;
    value = z80.regs.b;
    z80.regs.b = value;
});
decodeMapBASE.set(0x41, (z80: Z80) => { // ld b,c
    let value: number;
    value = z80.regs.c;
    z80.regs.b = value;
});
decodeMapBASE.set(0x42, (z80: Z80) => { // ld b,d
    let value: number;
    value = z80.regs.d;
    z80.regs.b = value;
});
decodeMapBASE.set(0x43, (z80: Z80) => { // ld b,e
    let value: number;
    value = z80.regs.e;
    z80.regs.b = value;
});
decodeMapBASE.set(0x44, (z80: Z80) => { // ld b,h
    let value: number;
    value = z80.regs.h;
    z80.regs.b = value;
});
decodeMapBASE.set(0x45, (z80: Z80) => { // ld b,l
    let value: number;
    value = z80.regs.l;
    z80.regs.b = value;
});
decodeMapBASE.set(0x46, (z80: Z80) => { // ld b,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.b = value;
});
decodeMapBASE.set(0x47, (z80: Z80) => { // ld b,a
    let value: number;
    value = z80.regs.a;
    z80.regs.b = value;
});
decodeMapBASE.set(0x48, (z80: Z80) => { // ld c,b
    let value: number;
    value = z80.regs.b;
    z80.regs.c = value;
});
decodeMapBASE.set(0x49, (z80: Z80) => { // ld c,c
    let value: number;
    value = z80.regs.c;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4A, (z80: Z80) => { // ld c,d
    let value: number;
    value = z80.regs.d;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4B, (z80: Z80) => { // ld c,e
    let value: number;
    value = z80.regs.e;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4C, (z80: Z80) => { // ld c,h
    let value: number;
    value = z80.regs.h;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4D, (z80: Z80) => { // ld c,l
    let value: number;
    value = z80.regs.l;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4E, (z80: Z80) => { // ld c,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.c = value;
});
decodeMapBASE.set(0x4F, (z80: Z80) => { // ld c,a
    let value: number;
    value = z80.regs.a;
    z80.regs.c = value;
});
decodeMapBASE.set(0x50, (z80: Z80) => { // ld d,b
    let value: number;
    value = z80.regs.b;
    z80.regs.d = value;
});
decodeMapBASE.set(0x51, (z80: Z80) => { // ld d,c
    let value: number;
    value = z80.regs.c;
    z80.regs.d = value;
});
decodeMapBASE.set(0x52, (z80: Z80) => { // ld d,d
    let value: number;
    value = z80.regs.d;
    z80.regs.d = value;
});
decodeMapBASE.set(0x53, (z80: Z80) => { // ld d,e
    let value: number;
    value = z80.regs.e;
    z80.regs.d = value;
});
decodeMapBASE.set(0x54, (z80: Z80) => { // ld d,h
    let value: number;
    value = z80.regs.h;
    z80.regs.d = value;
});
decodeMapBASE.set(0x55, (z80: Z80) => { // ld d,l
    let value: number;
    value = z80.regs.l;
    z80.regs.d = value;
});
decodeMapBASE.set(0x56, (z80: Z80) => { // ld d,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.d = value;
});
decodeMapBASE.set(0x57, (z80: Z80) => { // ld d,a
    let value: number;
    value = z80.regs.a;
    z80.regs.d = value;
});
decodeMapBASE.set(0x58, (z80: Z80) => { // ld e,b
    let value: number;
    value = z80.regs.b;
    z80.regs.e = value;
});
decodeMapBASE.set(0x59, (z80: Z80) => { // ld e,c
    let value: number;
    value = z80.regs.c;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5A, (z80: Z80) => { // ld e,d
    let value: number;
    value = z80.regs.d;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5B, (z80: Z80) => { // ld e,e
    let value: number;
    value = z80.regs.e;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5C, (z80: Z80) => { // ld e,h
    let value: number;
    value = z80.regs.h;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5D, (z80: Z80) => { // ld e,l
    let value: number;
    value = z80.regs.l;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5E, (z80: Z80) => { // ld e,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.e = value;
});
decodeMapBASE.set(0x5F, (z80: Z80) => { // ld e,a
    let value: number;
    value = z80.regs.a;
    z80.regs.e = value;
});
decodeMapBASE.set(0x60, (z80: Z80) => { // ld h,b
    let value: number;
    value = z80.regs.b;
    z80.regs.h = value;
});
decodeMapBASE.set(0x61, (z80: Z80) => { // ld h,c
    let value: number;
    value = z80.regs.c;
    z80.regs.h = value;
});
decodeMapBASE.set(0x62, (z80: Z80) => { // ld h,d
    let value: number;
    value = z80.regs.d;
    z80.regs.h = value;
});
decodeMapBASE.set(0x63, (z80: Z80) => { // ld h,e
    let value: number;
    value = z80.regs.e;
    z80.regs.h = value;
});
decodeMapBASE.set(0x64, (z80: Z80) => { // ld h,h
    let value: number;
    value = z80.regs.h;
    z80.regs.h = value;
});
decodeMapBASE.set(0x65, (z80: Z80) => { // ld h,l
    let value: number;
    value = z80.regs.l;
    z80.regs.h = value;
});
decodeMapBASE.set(0x66, (z80: Z80) => { // ld h,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.h = value;
});
decodeMapBASE.set(0x67, (z80: Z80) => { // ld h,a
    let value: number;
    value = z80.regs.a;
    z80.regs.h = value;
});
decodeMapBASE.set(0x68, (z80: Z80) => { // ld l,b
    let value: number;
    value = z80.regs.b;
    z80.regs.l = value;
});
decodeMapBASE.set(0x69, (z80: Z80) => { // ld l,c
    let value: number;
    value = z80.regs.c;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6A, (z80: Z80) => { // ld l,d
    let value: number;
    value = z80.regs.d;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6B, (z80: Z80) => { // ld l,e
    let value: number;
    value = z80.regs.e;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6C, (z80: Z80) => { // ld l,h
    let value: number;
    value = z80.regs.h;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6D, (z80: Z80) => { // ld l,l
    let value: number;
    value = z80.regs.l;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6E, (z80: Z80) => { // ld l,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.l = value;
});
decodeMapBASE.set(0x6F, (z80: Z80) => { // ld l,a
    let value: number;
    value = z80.regs.a;
    z80.regs.l = value;
});
decodeMapBASE.set(0x70, (z80: Z80) => { // ld (hl),b
    let value: number;
    value = z80.regs.b;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x71, (z80: Z80) => { // ld (hl),c
    let value: number;
    value = z80.regs.c;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x72, (z80: Z80) => { // ld (hl),d
    let value: number;
    value = z80.regs.d;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x73, (z80: Z80) => { // ld (hl),e
    let value: number;
    value = z80.regs.e;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x74, (z80: Z80) => { // ld (hl),h
    let value: number;
    value = z80.regs.h;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x75, (z80: Z80) => { // ld (hl),l
    let value: number;
    value = z80.regs.l;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x76, (z80: Z80) => { // halt
    z80.regs.halted = 1;
    z80.regs.pc = dec16(z80.regs.pc);
});
decodeMapBASE.set(0x77, (z80: Z80) => { // ld (hl),a
    let value: number;
    value = z80.regs.a;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x78, (z80: Z80) => { // ld a,b
    let value: number;
    value = z80.regs.b;
    z80.regs.a = value;
});
decodeMapBASE.set(0x79, (z80: Z80) => { // ld a,c
    let value: number;
    value = z80.regs.c;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7A, (z80: Z80) => { // ld a,d
    let value: number;
    value = z80.regs.d;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7B, (z80: Z80) => { // ld a,e
    let value: number;
    value = z80.regs.e;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7C, (z80: Z80) => { // ld a,h
    let value: number;
    value = z80.regs.h;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7D, (z80: Z80) => { // ld a,l
    let value: number;
    value = z80.regs.l;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7E, (z80: Z80) => { // ld a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a = value;
});
decodeMapBASE.set(0x7F, (z80: Z80) => { // ld a,a
    let value: number;
    value = z80.regs.a;
    z80.regs.a = value;
});
decodeMapBASE.set(0x80, (z80: Z80) => { // add a,b
    let value: number;
    value = z80.regs.b;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x81, (z80: Z80) => { // add a,c
    let value: number;
    value = z80.regs.c;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x82, (z80: Z80) => { // add a,d
    let value: number;
    value = z80.regs.d;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x83, (z80: Z80) => { // add a,e
    let value: number;
    value = z80.regs.e;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x84, (z80: Z80) => { // add a,h
    let value: number;
    value = z80.regs.h;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x85, (z80: Z80) => { // add a,l
    let value: number;
    value = z80.regs.l;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x86, (z80: Z80) => { // add a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x87, (z80: Z80) => { // add a,a
    let value: number;
    value = z80.regs.a;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x88, (z80: Z80) => { // adc a,b
    let value: number;
    value = z80.regs.b;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x89, (z80: Z80) => { // adc a,c
    let value: number;
    value = z80.regs.c;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8A, (z80: Z80) => { // adc a,d
    let value: number;
    value = z80.regs.d;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8B, (z80: Z80) => { // adc a,e
    let value: number;
    value = z80.regs.e;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8C, (z80: Z80) => { // adc a,h
    let value: number;
    value = z80.regs.h;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8D, (z80: Z80) => { // adc a,l
    let value: number;
    value = z80.regs.l;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8E, (z80: Z80) => { // adc a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8F, (z80: Z80) => { // adc a,a
    let value: number;
    value = z80.regs.a;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x90, (z80: Z80) => { // sub a,b
    let value: number;
    value = z80.regs.b;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x91, (z80: Z80) => { // sub a,c
    let value: number;
    value = z80.regs.c;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x92, (z80: Z80) => { // sub a,d
    let value: number;
    value = z80.regs.d;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x93, (z80: Z80) => { // sub a,e
    let value: number;
    value = z80.regs.e;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x94, (z80: Z80) => { // sub a,h
    let value: number;
    value = z80.regs.h;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x95, (z80: Z80) => { // sub a,l
    let value: number;
    value = z80.regs.l;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x96, (z80: Z80) => { // sub a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x97, (z80: Z80) => { // sub a,a
    let value: number;
    value = z80.regs.a;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x98, (z80: Z80) => { // sbc a,b
    let value: number;
    value = z80.regs.b;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x99, (z80: Z80) => { // sbc a,c
    let value: number;
    value = z80.regs.c;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9A, (z80: Z80) => { // sbc a,d
    let value: number;
    value = z80.regs.d;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9B, (z80: Z80) => { // sbc a,e
    let value: number;
    value = z80.regs.e;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9C, (z80: Z80) => { // sbc a,h
    let value: number;
    value = z80.regs.h;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9D, (z80: Z80) => { // sbc a,l
    let value: number;
    value = z80.regs.l;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9E, (z80: Z80) => { // sbc a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9F, (z80: Z80) => { // sbc a,a
    let value: number;
    value = z80.regs.a;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xA0, (z80: Z80) => { // and a,b
    let value: number;
    value = z80.regs.b;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA1, (z80: Z80) => { // and a,c
    let value: number;
    value = z80.regs.c;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA2, (z80: Z80) => { // and a,d
    let value: number;
    value = z80.regs.d;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA3, (z80: Z80) => { // and a,e
    let value: number;
    value = z80.regs.e;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA4, (z80: Z80) => { // and a,h
    let value: number;
    value = z80.regs.h;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA5, (z80: Z80) => { // and a,l
    let value: number;
    value = z80.regs.l;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA6, (z80: Z80) => { // and a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA7, (z80: Z80) => { // and a,a
    let value: number;
    value = z80.regs.a;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xA8, (z80: Z80) => { // xor a,b
    let value: number;
    value = z80.regs.b;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xA9, (z80: Z80) => { // xor a,c
    let value: number;
    value = z80.regs.c;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAA, (z80: Z80) => { // xor a,d
    let value: number;
    value = z80.regs.d;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAB, (z80: Z80) => { // xor a,e
    let value: number;
    value = z80.regs.e;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAC, (z80: Z80) => { // xor a,h
    let value: number;
    value = z80.regs.h;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAD, (z80: Z80) => { // xor a,l
    let value: number;
    value = z80.regs.l;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAE, (z80: Z80) => { // xor a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAF, (z80: Z80) => { // xor a,a
    let value: number;
    value = z80.regs.a;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB0, (z80: Z80) => { // or a,b
    let value: number;
    value = z80.regs.b;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB1, (z80: Z80) => { // or a,c
    let value: number;
    value = z80.regs.c;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB2, (z80: Z80) => { // or a,d
    let value: number;
    value = z80.regs.d;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB3, (z80: Z80) => { // or a,e
    let value: number;
    value = z80.regs.e;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB4, (z80: Z80) => { // or a,h
    let value: number;
    value = z80.regs.h;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB5, (z80: Z80) => { // or a,l
    let value: number;
    value = z80.regs.l;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB6, (z80: Z80) => { // or a,(hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB7, (z80: Z80) => { // or a,a
    let value: number;
    value = z80.regs.a;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB8, (z80: Z80) => { // cp b
    let value: number;
    value = z80.regs.b;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xB9, (z80: Z80) => { // cp c
    let value: number;
    value = z80.regs.c;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBA, (z80: Z80) => { // cp d
    let value: number;
    value = z80.regs.d;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBB, (z80: Z80) => { // cp e
    let value: number;
    value = z80.regs.e;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBC, (z80: Z80) => { // cp h
    let value: number;
    value = z80.regs.h;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBD, (z80: Z80) => { // cp l
    let value: number;
    value = z80.regs.l;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBE, (z80: Z80) => { // cp (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xBF, (z80: Z80) => { // cp a
    let value: number;
    value = z80.regs.a;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xC0, (z80: Z80) => { // ret nz
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.Z) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xC1, (z80: Z80) => { // pop bc
    z80.regs.bc = z80.popWord();
});
decodeMapBASE.set(0xC2, (z80: Z80) => { // jp nz,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.Z) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xC3, (z80: Z80) => { // jp nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.pc = z80.regs.memptr;
});
decodeMapBASE.set(0xC4, (z80: Z80) => { // call nz,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.Z) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xC5, (z80: Z80) => { // push bc
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.bc);
});
decodeMapBASE.set(0xC6, (z80: Z80) => { // add a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xC7, (z80: Z80) => { // rst 00
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0000;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xC8, (z80: Z80) => { // ret z
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.Z) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xC9, (z80: Z80) => { // ret
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xCA, (z80: Z80) => { // jp z,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.Z) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xCB, (z80: Z80) => { // shift cb
    decodeCB(z80);
});
decodeMapBASE.set(0xCC, (z80: Z80) => { // call z,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.Z) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xCD, (z80: Z80) => { // call nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = z80.regs.memptr;
});
decodeMapBASE.set(0xCE, (z80: Z80) => { // adc a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xCF, (z80: Z80) => { // rst 8
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0008;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xD0, (z80: Z80) => { // ret nc
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.C) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xD1, (z80: Z80) => { // pop de
    z80.regs.de = z80.popWord();
});
decodeMapBASE.set(0xD2, (z80: Z80) => { // jp nc,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.C) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xD3, (z80: Z80) => { // out (nn),a
    const port = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.regs.a, inc8(port));
    z80.writePort(word(z80.regs.a, port), z80.regs.a);
});
decodeMapBASE.set(0xD4, (z80: Z80) => { // call nc,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.C) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xD5, (z80: Z80) => { // push de
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.de);
});
decodeMapBASE.set(0xD6, (z80: Z80) => { // sub a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xD7, (z80: Z80) => { // rst 10
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0010;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xD8, (z80: Z80) => { // ret c
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.C) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xD9, (z80: Z80) => { // exx
    let tmp: number;
    tmp = z80.regs.bc; z80.regs.bc = z80.regs.bcPrime; z80.regs.bcPrime = tmp;
    tmp = z80.regs.de; z80.regs.de = z80.regs.dePrime; z80.regs.dePrime = tmp;
    tmp = z80.regs.hl; z80.regs.hl = z80.regs.hlPrime; z80.regs.hlPrime = tmp;
});
decodeMapBASE.set(0xDA, (z80: Z80) => { // jp c,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.C) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xDB, (z80: Z80) => { // in a,(nn)
    const port = word(z80.regs.a, z80.readByte(z80.regs.pc));
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.a = z80.readPort(port);
    z80.regs.memptr = inc16(port);
});
decodeMapBASE.set(0xDC, (z80: Z80) => { // call c,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.C) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xDD, (z80: Z80) => { // shift dd
    decodeDD(z80);
});
decodeMapBASE.set(0xDE, (z80: Z80) => { // sbc a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xDF, (z80: Z80) => { // rst 18
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0018;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xE0, (z80: Z80) => { // ret po
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.P) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xE1, (z80: Z80) => { // pop hl
    z80.regs.hl = z80.popWord();
});
decodeMapBASE.set(0xE2, (z80: Z80) => { // jp po,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.P) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xE3, (z80: Z80) => { // ex (sp),hl
    const rightValue = z80.regs.hl;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
    z80.writeByte(z80.regs.sp, lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = word(leftValueH, leftValueL);
    z80.regs.hl = word(leftValueH, leftValueL);
});
decodeMapBASE.set(0xE4, (z80: Z80) => { // call po,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.P) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xE5, (z80: Z80) => { // push hl
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.hl);
});
decodeMapBASE.set(0xE6, (z80: Z80) => { // and nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapBASE.set(0xE7, (z80: Z80) => { // rst 20
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0020;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xE8, (z80: Z80) => { // ret pe
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.P) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xE9, (z80: Z80) => { // jp hl
    z80.regs.pc = z80.regs.hl;
});
decodeMapBASE.set(0xEA, (z80: Z80) => { // jp pe,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.P) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xEB, (z80: Z80) => { // ex de,hl
    const rightValue = z80.regs.hl;
    z80.regs.hl = z80.regs.de;
    z80.regs.de = rightValue;
});
decodeMapBASE.set(0xEC, (z80: Z80) => { // call pe,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.P) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xED, (z80: Z80) => { // shift ed
    decodeED(z80);
});
decodeMapBASE.set(0xEE, (z80: Z80) => { // xor a,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xEF, (z80: Z80) => { // rst 28
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0028;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xF0, (z80: Z80) => { // ret p
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.S) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xF1, (z80: Z80) => { // pop af
    z80.regs.af = z80.popWord();
});
decodeMapBASE.set(0xF2, (z80: Z80) => { // jp p,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.S) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xF3, (z80: Z80) => { // di
    z80.regs.iff1 = 0;
    z80.regs.iff2 = 0;
});
decodeMapBASE.set(0xF4, (z80: Z80) => { // call p,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.S) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xF5, (z80: Z80) => { // push af
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.af);
});
decodeMapBASE.set(0xF6, (z80: Z80) => { // or nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xF7, (z80: Z80) => { // rst 30
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0030;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xF8, (z80: Z80) => { // ret m
    z80.incTStateCount(1);
    if ((z80.regs.f & Flag.S) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xF9, (z80: Z80) => { // ld sp,hl
    let value: number;
    value = z80.regs.hl;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});
decodeMapBASE.set(0xFA, (z80: Z80) => { // jp m,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.S) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xFB, (z80: Z80) => { // ei
    z80.regs.iff1 = 1;
    z80.regs.iff2 = 1;
});
decodeMapBASE.set(0xFC, (z80: Z80) => { // call m,nnnn
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = inc16(z80.regs.pc);
    if ((z80.regs.f & Flag.S) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xFD, (z80: Z80) => { // shift fd
    decodeFD(z80);
});
decodeMapBASE.set(0xFE, (z80: Z80) => { // cp nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapBASE.set(0xFF, (z80: Z80) => { // rst 38
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0038;
    z80.regs.memptr = z80.regs.pc;
});

const decodeMapCB = new Map<number, OpcodeFunc>();
decodeMapCB.set(0x00, (z80: Z80) => { // rlc b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x01, (z80: Z80) => { // rlc c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x02, (z80: Z80) => { // rlc d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x03, (z80: Z80) => { // rlc e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x04, (z80: Z80) => { // rlc h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x05, (z80: Z80) => { // rlc l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x06, (z80: Z80) => { // rlc (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x07, (z80: Z80) => { // rlc a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x08, (z80: Z80) => { // rrc b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x09, (z80: Z80) => { // rrc c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x0A, (z80: Z80) => { // rrc d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x0B, (z80: Z80) => { // rrc e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x0C, (z80: Z80) => { // rrc h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x0D, (z80: Z80) => { // rrc l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x0E, (z80: Z80) => { // rrc (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x0F, (z80: Z80) => { // rrc a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x10, (z80: Z80) => { // rl b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x11, (z80: Z80) => { // rl c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x12, (z80: Z80) => { // rl d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x13, (z80: Z80) => { // rl e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x14, (z80: Z80) => { // rl h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x15, (z80: Z80) => { // rl l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x16, (z80: Z80) => { // rl (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x17, (z80: Z80) => { // rl a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x18, (z80: Z80) => { // rr b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x19, (z80: Z80) => { // rr c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x1A, (z80: Z80) => { // rr d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x1B, (z80: Z80) => { // rr e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x1C, (z80: Z80) => { // rr h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x1D, (z80: Z80) => { // rr l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x1E, (z80: Z80) => { // rr (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x1F, (z80: Z80) => { // rr a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x20, (z80: Z80) => { // sla b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x21, (z80: Z80) => { // sla c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x22, (z80: Z80) => { // sla d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x23, (z80: Z80) => { // sla e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x24, (z80: Z80) => { // sla h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x25, (z80: Z80) => { // sla l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x26, (z80: Z80) => { // sla (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x27, (z80: Z80) => { // sla a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x28, (z80: Z80) => { // sra b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x29, (z80: Z80) => { // sra c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x2A, (z80: Z80) => { // sra d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x2B, (z80: Z80) => { // sra e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x2C, (z80: Z80) => { // sra h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x2D, (z80: Z80) => { // sra l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x2E, (z80: Z80) => { // sra (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x2F, (z80: Z80) => { // sra a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x30, (z80: Z80) => { // sll b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x31, (z80: Z80) => { // sll c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x32, (z80: Z80) => { // sll d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x33, (z80: Z80) => { // sll e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x34, (z80: Z80) => { // sll h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x35, (z80: Z80) => { // sll l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x36, (z80: Z80) => { // sll (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x37, (z80: Z80) => { // sll a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x38, (z80: Z80) => { // srl b
    let value: number;
    value = z80.regs.b;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x39, (z80: Z80) => { // srl c
    let value: number;
    value = z80.regs.c;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x3A, (z80: Z80) => { // srl d
    let value: number;
    value = z80.regs.d;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x3B, (z80: Z80) => { // srl e
    let value: number;
    value = z80.regs.e;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x3C, (z80: Z80) => { // srl h
    let value: number;
    value = z80.regs.h;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x3D, (z80: Z80) => { // srl l
    let value: number;
    value = z80.regs.l;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x3E, (z80: Z80) => { // srl (hl)
    let value: number;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x3F, (z80: Z80) => { // srl a
    let value: number;
    value = z80.regs.a;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x40, (z80: Z80) => { // bit 0,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x41, (z80: Z80) => { // bit 0,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x42, (z80: Z80) => { // bit 0,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x43, (z80: Z80) => { // bit 0,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x44, (z80: Z80) => { // bit 0,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x45, (z80: Z80) => { // bit 0,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x46, (z80: Z80) => { // bit 0,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x47, (z80: Z80) => { // bit 0,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x48, (z80: Z80) => { // bit 1,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x49, (z80: Z80) => { // bit 1,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4A, (z80: Z80) => { // bit 1,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4B, (z80: Z80) => { // bit 1,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4C, (z80: Z80) => { // bit 1,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4D, (z80: Z80) => { // bit 1,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4E, (z80: Z80) => { // bit 1,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4F, (z80: Z80) => { // bit 1,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x50, (z80: Z80) => { // bit 2,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x51, (z80: Z80) => { // bit 2,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x52, (z80: Z80) => { // bit 2,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x53, (z80: Z80) => { // bit 2,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x54, (z80: Z80) => { // bit 2,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x55, (z80: Z80) => { // bit 2,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x56, (z80: Z80) => { // bit 2,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x57, (z80: Z80) => { // bit 2,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x58, (z80: Z80) => { // bit 3,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x59, (z80: Z80) => { // bit 3,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5A, (z80: Z80) => { // bit 3,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5B, (z80: Z80) => { // bit 3,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5C, (z80: Z80) => { // bit 3,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5D, (z80: Z80) => { // bit 3,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5E, (z80: Z80) => { // bit 3,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5F, (z80: Z80) => { // bit 3,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x60, (z80: Z80) => { // bit 4,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x61, (z80: Z80) => { // bit 4,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x62, (z80: Z80) => { // bit 4,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x63, (z80: Z80) => { // bit 4,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x64, (z80: Z80) => { // bit 4,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x65, (z80: Z80) => { // bit 4,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x66, (z80: Z80) => { // bit 4,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x67, (z80: Z80) => { // bit 4,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x68, (z80: Z80) => { // bit 5,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x69, (z80: Z80) => { // bit 5,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6A, (z80: Z80) => { // bit 5,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6B, (z80: Z80) => { // bit 5,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6C, (z80: Z80) => { // bit 5,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6D, (z80: Z80) => { // bit 5,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6E, (z80: Z80) => { // bit 5,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6F, (z80: Z80) => { // bit 5,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x70, (z80: Z80) => { // bit 6,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x71, (z80: Z80) => { // bit 6,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x72, (z80: Z80) => { // bit 6,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x73, (z80: Z80) => { // bit 6,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x74, (z80: Z80) => { // bit 6,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x75, (z80: Z80) => { // bit 6,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x76, (z80: Z80) => { // bit 6,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x77, (z80: Z80) => { // bit 6,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x78, (z80: Z80) => { // bit 7,b
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x79, (z80: Z80) => { // bit 7,c
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7A, (z80: Z80) => { // bit 7,d
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7B, (z80: Z80) => { // bit 7,e
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7C, (z80: Z80) => { // bit 7,h
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7D, (z80: Z80) => { // bit 7,l
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7E, (z80: Z80) => { // bit 7,(hl)
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7F, (z80: Z80) => { // bit 7,a
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x80, (z80: Z80) => { // res 0,b
    z80.regs.b &= 0xFE;
});
decodeMapCB.set(0x81, (z80: Z80) => { // res 0,c
    z80.regs.c &= 0xFE;
});
decodeMapCB.set(0x82, (z80: Z80) => { // res 0,d
    z80.regs.d &= 0xFE;
});
decodeMapCB.set(0x83, (z80: Z80) => { // res 0,e
    z80.regs.e &= 0xFE;
});
decodeMapCB.set(0x84, (z80: Z80) => { // res 0,h
    z80.regs.h &= 0xFE;
});
decodeMapCB.set(0x85, (z80: Z80) => { // res 0,l
    z80.regs.l &= 0xFE;
});
decodeMapCB.set(0x86, (z80: Z80) => { // res 0,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFE);
});
decodeMapCB.set(0x87, (z80: Z80) => { // res 0,a
    z80.regs.a &= 0xFE;
});
decodeMapCB.set(0x88, (z80: Z80) => { // res 1,b
    z80.regs.b &= 0xFD;
});
decodeMapCB.set(0x89, (z80: Z80) => { // res 1,c
    z80.regs.c &= 0xFD;
});
decodeMapCB.set(0x8A, (z80: Z80) => { // res 1,d
    z80.regs.d &= 0xFD;
});
decodeMapCB.set(0x8B, (z80: Z80) => { // res 1,e
    z80.regs.e &= 0xFD;
});
decodeMapCB.set(0x8C, (z80: Z80) => { // res 1,h
    z80.regs.h &= 0xFD;
});
decodeMapCB.set(0x8D, (z80: Z80) => { // res 1,l
    z80.regs.l &= 0xFD;
});
decodeMapCB.set(0x8E, (z80: Z80) => { // res 1,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFD);
});
decodeMapCB.set(0x8F, (z80: Z80) => { // res 1,a
    z80.regs.a &= 0xFD;
});
decodeMapCB.set(0x90, (z80: Z80) => { // res 2,b
    z80.regs.b &= 0xFB;
});
decodeMapCB.set(0x91, (z80: Z80) => { // res 2,c
    z80.regs.c &= 0xFB;
});
decodeMapCB.set(0x92, (z80: Z80) => { // res 2,d
    z80.regs.d &= 0xFB;
});
decodeMapCB.set(0x93, (z80: Z80) => { // res 2,e
    z80.regs.e &= 0xFB;
});
decodeMapCB.set(0x94, (z80: Z80) => { // res 2,h
    z80.regs.h &= 0xFB;
});
decodeMapCB.set(0x95, (z80: Z80) => { // res 2,l
    z80.regs.l &= 0xFB;
});
decodeMapCB.set(0x96, (z80: Z80) => { // res 2,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFB);
});
decodeMapCB.set(0x97, (z80: Z80) => { // res 2,a
    z80.regs.a &= 0xFB;
});
decodeMapCB.set(0x98, (z80: Z80) => { // res 3,b
    z80.regs.b &= 0xF7;
});
decodeMapCB.set(0x99, (z80: Z80) => { // res 3,c
    z80.regs.c &= 0xF7;
});
decodeMapCB.set(0x9A, (z80: Z80) => { // res 3,d
    z80.regs.d &= 0xF7;
});
decodeMapCB.set(0x9B, (z80: Z80) => { // res 3,e
    z80.regs.e &= 0xF7;
});
decodeMapCB.set(0x9C, (z80: Z80) => { // res 3,h
    z80.regs.h &= 0xF7;
});
decodeMapCB.set(0x9D, (z80: Z80) => { // res 3,l
    z80.regs.l &= 0xF7;
});
decodeMapCB.set(0x9E, (z80: Z80) => { // res 3,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xF7);
});
decodeMapCB.set(0x9F, (z80: Z80) => { // res 3,a
    z80.regs.a &= 0xF7;
});
decodeMapCB.set(0xA0, (z80: Z80) => { // res 4,b
    z80.regs.b &= 0xEF;
});
decodeMapCB.set(0xA1, (z80: Z80) => { // res 4,c
    z80.regs.c &= 0xEF;
});
decodeMapCB.set(0xA2, (z80: Z80) => { // res 4,d
    z80.regs.d &= 0xEF;
});
decodeMapCB.set(0xA3, (z80: Z80) => { // res 4,e
    z80.regs.e &= 0xEF;
});
decodeMapCB.set(0xA4, (z80: Z80) => { // res 4,h
    z80.regs.h &= 0xEF;
});
decodeMapCB.set(0xA5, (z80: Z80) => { // res 4,l
    z80.regs.l &= 0xEF;
});
decodeMapCB.set(0xA6, (z80: Z80) => { // res 4,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xEF);
});
decodeMapCB.set(0xA7, (z80: Z80) => { // res 4,a
    z80.regs.a &= 0xEF;
});
decodeMapCB.set(0xA8, (z80: Z80) => { // res 5,b
    z80.regs.b &= 0xDF;
});
decodeMapCB.set(0xA9, (z80: Z80) => { // res 5,c
    z80.regs.c &= 0xDF;
});
decodeMapCB.set(0xAA, (z80: Z80) => { // res 5,d
    z80.regs.d &= 0xDF;
});
decodeMapCB.set(0xAB, (z80: Z80) => { // res 5,e
    z80.regs.e &= 0xDF;
});
decodeMapCB.set(0xAC, (z80: Z80) => { // res 5,h
    z80.regs.h &= 0xDF;
});
decodeMapCB.set(0xAD, (z80: Z80) => { // res 5,l
    z80.regs.l &= 0xDF;
});
decodeMapCB.set(0xAE, (z80: Z80) => { // res 5,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xDF);
});
decodeMapCB.set(0xAF, (z80: Z80) => { // res 5,a
    z80.regs.a &= 0xDF;
});
decodeMapCB.set(0xB0, (z80: Z80) => { // res 6,b
    z80.regs.b &= 0xBF;
});
decodeMapCB.set(0xB1, (z80: Z80) => { // res 6,c
    z80.regs.c &= 0xBF;
});
decodeMapCB.set(0xB2, (z80: Z80) => { // res 6,d
    z80.regs.d &= 0xBF;
});
decodeMapCB.set(0xB3, (z80: Z80) => { // res 6,e
    z80.regs.e &= 0xBF;
});
decodeMapCB.set(0xB4, (z80: Z80) => { // res 6,h
    z80.regs.h &= 0xBF;
});
decodeMapCB.set(0xB5, (z80: Z80) => { // res 6,l
    z80.regs.l &= 0xBF;
});
decodeMapCB.set(0xB6, (z80: Z80) => { // res 6,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xBF);
});
decodeMapCB.set(0xB7, (z80: Z80) => { // res 6,a
    z80.regs.a &= 0xBF;
});
decodeMapCB.set(0xB8, (z80: Z80) => { // res 7,b
    z80.regs.b &= 0x7F;
});
decodeMapCB.set(0xB9, (z80: Z80) => { // res 7,c
    z80.regs.c &= 0x7F;
});
decodeMapCB.set(0xBA, (z80: Z80) => { // res 7,d
    z80.regs.d &= 0x7F;
});
decodeMapCB.set(0xBB, (z80: Z80) => { // res 7,e
    z80.regs.e &= 0x7F;
});
decodeMapCB.set(0xBC, (z80: Z80) => { // res 7,h
    z80.regs.h &= 0x7F;
});
decodeMapCB.set(0xBD, (z80: Z80) => { // res 7,l
    z80.regs.l &= 0x7F;
});
decodeMapCB.set(0xBE, (z80: Z80) => { // res 7,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0x7F);
});
decodeMapCB.set(0xBF, (z80: Z80) => { // res 7,a
    z80.regs.a &= 0x7F;
});
decodeMapCB.set(0xC0, (z80: Z80) => { // set 0,b
    z80.regs.b |= 0x01;
});
decodeMapCB.set(0xC1, (z80: Z80) => { // set 0,c
    z80.regs.c |= 0x01;
});
decodeMapCB.set(0xC2, (z80: Z80) => { // set 0,d
    z80.regs.d |= 0x01;
});
decodeMapCB.set(0xC3, (z80: Z80) => { // set 0,e
    z80.regs.e |= 0x01;
});
decodeMapCB.set(0xC4, (z80: Z80) => { // set 0,h
    z80.regs.h |= 0x01;
});
decodeMapCB.set(0xC5, (z80: Z80) => { // set 0,l
    z80.regs.l |= 0x01;
});
decodeMapCB.set(0xC6, (z80: Z80) => { // set 0,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x01);
});
decodeMapCB.set(0xC7, (z80: Z80) => { // set 0,a
    z80.regs.a |= 0x01;
});
decodeMapCB.set(0xC8, (z80: Z80) => { // set 1,b
    z80.regs.b |= 0x02;
});
decodeMapCB.set(0xC9, (z80: Z80) => { // set 1,c
    z80.regs.c |= 0x02;
});
decodeMapCB.set(0xCA, (z80: Z80) => { // set 1,d
    z80.regs.d |= 0x02;
});
decodeMapCB.set(0xCB, (z80: Z80) => { // set 1,e
    z80.regs.e |= 0x02;
});
decodeMapCB.set(0xCC, (z80: Z80) => { // set 1,h
    z80.regs.h |= 0x02;
});
decodeMapCB.set(0xCD, (z80: Z80) => { // set 1,l
    z80.regs.l |= 0x02;
});
decodeMapCB.set(0xCE, (z80: Z80) => { // set 1,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x02);
});
decodeMapCB.set(0xCF, (z80: Z80) => { // set 1,a
    z80.regs.a |= 0x02;
});
decodeMapCB.set(0xD0, (z80: Z80) => { // set 2,b
    z80.regs.b |= 0x04;
});
decodeMapCB.set(0xD1, (z80: Z80) => { // set 2,c
    z80.regs.c |= 0x04;
});
decodeMapCB.set(0xD2, (z80: Z80) => { // set 2,d
    z80.regs.d |= 0x04;
});
decodeMapCB.set(0xD3, (z80: Z80) => { // set 2,e
    z80.regs.e |= 0x04;
});
decodeMapCB.set(0xD4, (z80: Z80) => { // set 2,h
    z80.regs.h |= 0x04;
});
decodeMapCB.set(0xD5, (z80: Z80) => { // set 2,l
    z80.regs.l |= 0x04;
});
decodeMapCB.set(0xD6, (z80: Z80) => { // set 2,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x04);
});
decodeMapCB.set(0xD7, (z80: Z80) => { // set 2,a
    z80.regs.a |= 0x04;
});
decodeMapCB.set(0xD8, (z80: Z80) => { // set 3,b
    z80.regs.b |= 0x08;
});
decodeMapCB.set(0xD9, (z80: Z80) => { // set 3,c
    z80.regs.c |= 0x08;
});
decodeMapCB.set(0xDA, (z80: Z80) => { // set 3,d
    z80.regs.d |= 0x08;
});
decodeMapCB.set(0xDB, (z80: Z80) => { // set 3,e
    z80.regs.e |= 0x08;
});
decodeMapCB.set(0xDC, (z80: Z80) => { // set 3,h
    z80.regs.h |= 0x08;
});
decodeMapCB.set(0xDD, (z80: Z80) => { // set 3,l
    z80.regs.l |= 0x08;
});
decodeMapCB.set(0xDE, (z80: Z80) => { // set 3,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x08);
});
decodeMapCB.set(0xDF, (z80: Z80) => { // set 3,a
    z80.regs.a |= 0x08;
});
decodeMapCB.set(0xE0, (z80: Z80) => { // set 4,b
    z80.regs.b |= 0x10;
});
decodeMapCB.set(0xE1, (z80: Z80) => { // set 4,c
    z80.regs.c |= 0x10;
});
decodeMapCB.set(0xE2, (z80: Z80) => { // set 4,d
    z80.regs.d |= 0x10;
});
decodeMapCB.set(0xE3, (z80: Z80) => { // set 4,e
    z80.regs.e |= 0x10;
});
decodeMapCB.set(0xE4, (z80: Z80) => { // set 4,h
    z80.regs.h |= 0x10;
});
decodeMapCB.set(0xE5, (z80: Z80) => { // set 4,l
    z80.regs.l |= 0x10;
});
decodeMapCB.set(0xE6, (z80: Z80) => { // set 4,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x10);
});
decodeMapCB.set(0xE7, (z80: Z80) => { // set 4,a
    z80.regs.a |= 0x10;
});
decodeMapCB.set(0xE8, (z80: Z80) => { // set 5,b
    z80.regs.b |= 0x20;
});
decodeMapCB.set(0xE9, (z80: Z80) => { // set 5,c
    z80.regs.c |= 0x20;
});
decodeMapCB.set(0xEA, (z80: Z80) => { // set 5,d
    z80.regs.d |= 0x20;
});
decodeMapCB.set(0xEB, (z80: Z80) => { // set 5,e
    z80.regs.e |= 0x20;
});
decodeMapCB.set(0xEC, (z80: Z80) => { // set 5,h
    z80.regs.h |= 0x20;
});
decodeMapCB.set(0xED, (z80: Z80) => { // set 5,l
    z80.regs.l |= 0x20;
});
decodeMapCB.set(0xEE, (z80: Z80) => { // set 5,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x20);
});
decodeMapCB.set(0xEF, (z80: Z80) => { // set 5,a
    z80.regs.a |= 0x20;
});
decodeMapCB.set(0xF0, (z80: Z80) => { // set 6,b
    z80.regs.b |= 0x40;
});
decodeMapCB.set(0xF1, (z80: Z80) => { // set 6,c
    z80.regs.c |= 0x40;
});
decodeMapCB.set(0xF2, (z80: Z80) => { // set 6,d
    z80.regs.d |= 0x40;
});
decodeMapCB.set(0xF3, (z80: Z80) => { // set 6,e
    z80.regs.e |= 0x40;
});
decodeMapCB.set(0xF4, (z80: Z80) => { // set 6,h
    z80.regs.h |= 0x40;
});
decodeMapCB.set(0xF5, (z80: Z80) => { // set 6,l
    z80.regs.l |= 0x40;
});
decodeMapCB.set(0xF6, (z80: Z80) => { // set 6,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x40);
});
decodeMapCB.set(0xF7, (z80: Z80) => { // set 6,a
    z80.regs.a |= 0x40;
});
decodeMapCB.set(0xF8, (z80: Z80) => { // set 7,b
    z80.regs.b |= 0x80;
});
decodeMapCB.set(0xF9, (z80: Z80) => { // set 7,c
    z80.regs.c |= 0x80;
});
decodeMapCB.set(0xFA, (z80: Z80) => { // set 7,d
    z80.regs.d |= 0x80;
});
decodeMapCB.set(0xFB, (z80: Z80) => { // set 7,e
    z80.regs.e |= 0x80;
});
decodeMapCB.set(0xFC, (z80: Z80) => { // set 7,h
    z80.regs.h |= 0x80;
});
decodeMapCB.set(0xFD, (z80: Z80) => { // set 7,l
    z80.regs.l |= 0x80;
});
decodeMapCB.set(0xFE, (z80: Z80) => { // set 7,(hl)
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x80);
});
decodeMapCB.set(0xFF, (z80: Z80) => { // set 7,a
    z80.regs.a |= 0x80;
});

const decodeMapDD = new Map<number, OpcodeFunc>();
decodeMapDD.set(0x09, (z80: Z80) => { // add ix,bc
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x19, (z80: Z80) => { // add ix,de
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x21, (z80: Z80) => { // ld ix,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.ix = value;
});
decodeMapDD.set(0x22, (z80: Z80) => { // ld (nnnn),ix
    let value: number;
    value = z80.regs.ix;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapDD.set(0x23, (z80: Z80) => { // inc ix
    let value: number;
    value = z80.regs.ix;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x24, (z80: Z80) => { // inc ixh
    let value: number;
    value = z80.regs.ixh;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.ixh = value;
});
decodeMapDD.set(0x25, (z80: Z80) => { // dec ixh
    let value: number;
    value = z80.regs.ixh;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.ixh = value;
});
decodeMapDD.set(0x26, (z80: Z80) => { // ld ixh,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.ixh = value;
});
decodeMapDD.set(0x29, (z80: Z80) => { // add ix,ix
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.ix;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x2A, (z80: Z80) => { // ld ix,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x2B, (z80: Z80) => { // dec ix
    let value: number;
    value = z80.regs.ix;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x2C, (z80: Z80) => { // inc ixl
    let value: number;
    value = z80.regs.ixl;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.ixl = value;
});
decodeMapDD.set(0x2D, (z80: Z80) => { // dec ixl
    let value: number;
    value = z80.regs.ixl;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.ixl = value;
});
decodeMapDD.set(0x2E, (z80: Z80) => { // ld ixl,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.ixl = value;
});
decodeMapDD.set(0x34, (z80: Z80) => { // inc (ix+dd)
    let value: number;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.ix, signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x35, (z80: Z80) => { // dec (ix+dd)
    let value: number;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.ix, signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x36, (z80: Z80) => { // ld (ix+dd),nn
    const dd = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x39, (z80: Z80) => { // add ix,sp
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x44, (z80: Z80) => { // ld b,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.b = value;
});
decodeMapDD.set(0x45, (z80: Z80) => { // ld b,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.b = value;
});
decodeMapDD.set(0x46, (z80: Z80) => { // ld b,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.b = value;
});
decodeMapDD.set(0x4C, (z80: Z80) => { // ld c,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.c = value;
});
decodeMapDD.set(0x4D, (z80: Z80) => { // ld c,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.c = value;
});
decodeMapDD.set(0x4E, (z80: Z80) => { // ld c,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.c = value;
});
decodeMapDD.set(0x54, (z80: Z80) => { // ld d,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.d = value;
});
decodeMapDD.set(0x55, (z80: Z80) => { // ld d,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.d = value;
});
decodeMapDD.set(0x56, (z80: Z80) => { // ld d,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.d = value;
});
decodeMapDD.set(0x5C, (z80: Z80) => { // ld e,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.e = value;
});
decodeMapDD.set(0x5D, (z80: Z80) => { // ld e,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.e = value;
});
decodeMapDD.set(0x5E, (z80: Z80) => { // ld e,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.e = value;
});
decodeMapDD.set(0x60, (z80: Z80) => { // ld ixh,b
    let value: number;
    value = z80.regs.b;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x61, (z80: Z80) => { // ld ixh,c
    let value: number;
    value = z80.regs.c;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x62, (z80: Z80) => { // ld ixh,d
    let value: number;
    value = z80.regs.d;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x63, (z80: Z80) => { // ld ixh,e
    let value: number;
    value = z80.regs.e;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x64, (z80: Z80) => { // ld ixh,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x65, (z80: Z80) => { // ld ixh,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x66, (z80: Z80) => { // ld h,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.h = value;
});
decodeMapDD.set(0x67, (z80: Z80) => { // ld ixh,a
    let value: number;
    value = z80.regs.a;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x68, (z80: Z80) => { // ld ixl,b
    let value: number;
    value = z80.regs.b;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x69, (z80: Z80) => { // ld ixl,c
    let value: number;
    value = z80.regs.c;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6A, (z80: Z80) => { // ld ixl,d
    let value: number;
    value = z80.regs.d;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6B, (z80: Z80) => { // ld ixl,e
    let value: number;
    value = z80.regs.e;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6C, (z80: Z80) => { // ld ixl,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6D, (z80: Z80) => { // ld ixl,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6E, (z80: Z80) => { // ld l,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.l = value;
});
decodeMapDD.set(0x6F, (z80: Z80) => { // ld ixl,a
    let value: number;
    value = z80.regs.a;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x70, (z80: Z80) => { // ld (ix+dd),b
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.b;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x71, (z80: Z80) => { // ld (ix+dd),c
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.c;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x72, (z80: Z80) => { // ld (ix+dd),d
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.d;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x73, (z80: Z80) => { // ld (ix+dd),e
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.e;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x74, (z80: Z80) => { // ld (ix+dd),h
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.h;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x75, (z80: Z80) => { // ld (ix+dd),l
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.l;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x77, (z80: Z80) => { // ld (ix+dd),a
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.a;
    z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x7C, (z80: Z80) => { // ld a,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.a = value;
});
decodeMapDD.set(0x7D, (z80: Z80) => { // ld a,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.a = value;
});
decodeMapDD.set(0x7E, (z80: Z80) => { // ld a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a = value;
});
decodeMapDD.set(0x84, (z80: Z80) => { // add a,ixh
    let value: number;
    value = z80.regs.ixh;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x85, (z80: Z80) => { // add a,ixl
    let value: number;
    value = z80.regs.ixl;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x86, (z80: Z80) => { // add a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8C, (z80: Z80) => { // adc a,ixh
    let value: number;
    value = z80.regs.ixh;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8D, (z80: Z80) => { // adc a,ixl
    let value: number;
    value = z80.regs.ixl;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8E, (z80: Z80) => { // adc a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x94, (z80: Z80) => { // sub a,ixh
    let value: number;
    value = z80.regs.ixh;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x95, (z80: Z80) => { // sub a,ixl
    let value: number;
    value = z80.regs.ixl;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x96, (z80: Z80) => { // sub a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9C, (z80: Z80) => { // sbc a,ixh
    let value: number;
    value = z80.regs.ixh;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9D, (z80: Z80) => { // sbc a,ixl
    let value: number;
    value = z80.regs.ixl;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9E, (z80: Z80) => { // sbc a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0xA4, (z80: Z80) => { // and a,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapDD.set(0xA5, (z80: Z80) => { // and a,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapDD.set(0xA6, (z80: Z80) => { // and a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapDD.set(0xAC, (z80: Z80) => { // xor a,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xAD, (z80: Z80) => { // xor a,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xAE, (z80: Z80) => { // xor a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB4, (z80: Z80) => { // or a,ixh
    let value: number;
    value = z80.regs.ixh;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB5, (z80: Z80) => { // or a,ixl
    let value: number;
    value = z80.regs.ixl;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB6, (z80: Z80) => { // or a,(ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xBC, (z80: Z80) => { // cp ixh
    let value: number;
    value = z80.regs.ixh;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapDD.set(0xBD, (z80: Z80) => { // cp ixl
    let value: number;
    value = z80.regs.ixl;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapDD.set(0xBE, (z80: Z80) => { // cp (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapDD.set(0xCB, (z80: Z80) => { // shift ddcb
    decodeDDCB(z80);
});
decodeMapDD.set(0xE1, (z80: Z80) => { // pop ix
    z80.regs.ix = z80.popWord();
});
decodeMapDD.set(0xE3, (z80: Z80) => { // ex (sp),ix
    const rightValue = z80.regs.ix;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
    z80.writeByte(z80.regs.sp, lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = word(leftValueH, leftValueL);
    z80.regs.ix = word(leftValueH, leftValueL);
});
decodeMapDD.set(0xE5, (z80: Z80) => { // push ix
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.ix);
});
decodeMapDD.set(0xE9, (z80: Z80) => { // jp ix
    z80.regs.pc = z80.regs.ix;
});
decodeMapDD.set(0xF9, (z80: Z80) => { // ld sp,ix
    let value: number;
    value = z80.regs.ix;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});

const decodeMapDDCB = new Map<number, OpcodeFunc>();
decodeMapDDCB.set(0x00, (z80: Z80) => { // ld b,rlc
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x01, (z80: Z80) => { // ld c,rlc
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x02, (z80: Z80) => { // ld d,rlc
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x03, (z80: Z80) => { // ld e,rlc
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x04, (z80: Z80) => { // ld h,rlc
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x05, (z80: Z80) => { // ld l,rlc
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x06, (z80: Z80) => { // rlc (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x07, (z80: Z80) => { // ld a,rlc
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x08, (z80: Z80) => { // ld b,rrc
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x09, (z80: Z80) => { // ld c,rrc
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x0A, (z80: Z80) => { // ld d,rrc
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x0B, (z80: Z80) => { // ld e,rrc
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x0C, (z80: Z80) => { // ld h,rrc
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x0D, (z80: Z80) => { // ld l,rrc
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x0E, (z80: Z80) => { // rrc (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x0F, (z80: Z80) => { // ld a,rrc
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x10, (z80: Z80) => { // ld b,rl
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x11, (z80: Z80) => { // ld c,rl
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x12, (z80: Z80) => { // ld d,rl
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x13, (z80: Z80) => { // ld e,rl
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x14, (z80: Z80) => { // ld h,rl
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x15, (z80: Z80) => { // ld l,rl
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x16, (z80: Z80) => { // rl (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x17, (z80: Z80) => { // ld a,rl
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x18, (z80: Z80) => { // ld b,rr
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x19, (z80: Z80) => { // ld c,rr
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x1A, (z80: Z80) => { // ld d,rr
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x1B, (z80: Z80) => { // ld e,rr
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x1C, (z80: Z80) => { // ld h,rr
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x1D, (z80: Z80) => { // ld l,rr
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x1E, (z80: Z80) => { // rr (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x1F, (z80: Z80) => { // ld a,rr
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x20, (z80: Z80) => { // ld b,sla
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x21, (z80: Z80) => { // ld c,sla
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x22, (z80: Z80) => { // ld d,sla
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x23, (z80: Z80) => { // ld e,sla
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x24, (z80: Z80) => { // ld h,sla
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x25, (z80: Z80) => { // ld l,sla
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x26, (z80: Z80) => { // sla (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x27, (z80: Z80) => { // ld a,sla
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x28, (z80: Z80) => { // ld b,sra
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x29, (z80: Z80) => { // ld c,sra
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x2A, (z80: Z80) => { // ld d,sra
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x2B, (z80: Z80) => { // ld e,sra
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x2C, (z80: Z80) => { // ld h,sra
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x2D, (z80: Z80) => { // ld l,sra
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x2E, (z80: Z80) => { // sra (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x2F, (z80: Z80) => { // ld a,sra
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x30, (z80: Z80) => { // ld b,sll
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x31, (z80: Z80) => { // ld c,sll
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x32, (z80: Z80) => { // ld d,sll
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x33, (z80: Z80) => { // ld e,sll
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x34, (z80: Z80) => { // ld h,sll
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x35, (z80: Z80) => { // ld l,sll
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x36, (z80: Z80) => { // sll (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x37, (z80: Z80) => { // ld a,sll
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x38, (z80: Z80) => { // ld b,srl
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x39, (z80: Z80) => { // ld c,srl
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x3A, (z80: Z80) => { // ld d,srl
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x3B, (z80: Z80) => { // ld e,srl
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x3C, (z80: Z80) => { // ld h,srl
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x3D, (z80: Z80) => { // ld l,srl
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x3E, (z80: Z80) => { // srl (ix+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x3F, (z80: Z80) => { // ld a,srl
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x47, (z80: Z80) => { // bit 0,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x40, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x41, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x42, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x43, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x44, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x45, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x46, decodeMapDDCB.get(0x47) as OpcodeFunc);
decodeMapDDCB.set(0x4F, (z80: Z80) => { // bit 1,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x48, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x49, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x4A, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x4B, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x4C, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x4D, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x4E, decodeMapDDCB.get(0x4F) as OpcodeFunc);
decodeMapDDCB.set(0x57, (z80: Z80) => { // bit 2,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x50, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x51, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x52, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x53, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x54, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x55, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x56, decodeMapDDCB.get(0x57) as OpcodeFunc);
decodeMapDDCB.set(0x5F, (z80: Z80) => { // bit 3,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x58, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x59, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x5A, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x5B, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x5C, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x5D, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x5E, decodeMapDDCB.get(0x5F) as OpcodeFunc);
decodeMapDDCB.set(0x67, (z80: Z80) => { // bit 4,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x60, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x61, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x62, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x63, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x64, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x65, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x66, decodeMapDDCB.get(0x67) as OpcodeFunc);
decodeMapDDCB.set(0x6F, (z80: Z80) => { // bit 5,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x68, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x69, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x6A, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x6B, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x6C, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x6D, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x6E, decodeMapDDCB.get(0x6F) as OpcodeFunc);
decodeMapDDCB.set(0x77, (z80: Z80) => { // bit 6,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x70, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x71, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x72, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x73, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x74, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x75, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x76, decodeMapDDCB.get(0x77) as OpcodeFunc);
decodeMapDDCB.set(0x7F, (z80: Z80) => { // bit 7,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x78, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x79, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x7A, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x7B, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x7C, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x7D, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x7E, decodeMapDDCB.get(0x7F) as OpcodeFunc);
decodeMapDDCB.set(0x80, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x81, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x82, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x83, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x84, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x85, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x86, (z80: Z80) => { // res 0,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFE);
});
decodeMapDDCB.set(0x87, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x88, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x89, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x8A, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x8B, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x8C, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x8D, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x8E, (z80: Z80) => { // res 1,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFD);
});
decodeMapDDCB.set(0x8F, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x90, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x91, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x92, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x93, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x94, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x95, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x96, (z80: Z80) => { // res 2,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFB);
});
decodeMapDDCB.set(0x97, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x98, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x99, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x9A, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x9B, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x9C, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x9D, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x9E, (z80: Z80) => { // res 3,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xF7);
});
decodeMapDDCB.set(0x9F, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xA0, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xA1, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xA2, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xA3, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xA4, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xA5, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xA6, (z80: Z80) => { // res 4,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xEF);
});
decodeMapDDCB.set(0xA7, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xA8, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xA9, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xAA, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xAB, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xAC, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xAD, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xAE, (z80: Z80) => { // res 5,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xDF);
});
decodeMapDDCB.set(0xAF, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xB0, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xB1, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xB2, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xB3, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xB4, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xB5, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xB6, (z80: Z80) => { // res 6,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xBF);
});
decodeMapDDCB.set(0xB7, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xB8, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xB9, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xBA, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xBB, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xBC, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xBD, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xBE, (z80: Z80) => { // res 7,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0x7F);
});
decodeMapDDCB.set(0xBF, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xC0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xC1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xC2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xC3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xC4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xC5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xC6, (z80: Z80) => { // set 0,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x01);
});
decodeMapDDCB.set(0xC7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xC8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xC9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xCA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xCB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xCC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xCD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xCE, (z80: Z80) => { // set 1,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x02);
});
decodeMapDDCB.set(0xCF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xD0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xD1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xD2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xD3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xD4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xD5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xD6, (z80: Z80) => { // set 2,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x04);
});
decodeMapDDCB.set(0xD7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xD8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xD9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xDA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xDB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xDC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xDD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xDE, (z80: Z80) => { // set 3,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x08);
});
decodeMapDDCB.set(0xDF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xE0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xE1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xE2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xE3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xE4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xE5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xE6, (z80: Z80) => { // set 4,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x10);
});
decodeMapDDCB.set(0xE7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xE8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xE9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xEA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xEB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xEC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xED, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xEE, (z80: Z80) => { // set 5,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x20);
});
decodeMapDDCB.set(0xEF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xF0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xF1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xF2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xF3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xF4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xF5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xF6, (z80: Z80) => { // set 6,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x40);
});
decodeMapDDCB.set(0xF7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xF8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xF9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xFA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xFB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xFC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xFD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xFE, (z80: Z80) => { // set 7,(ix+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x80);
});
decodeMapDDCB.set(0xFF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});

const decodeMapED = new Map<number, OpcodeFunc>();
decodeMapED.set(0x40, (z80: Z80) => { // in b,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.b = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.b];
});
decodeMapED.set(0x41, (z80: Z80) => { // out (c),b
    z80.writePort(z80.regs.bc, z80.regs.b);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x42, (z80: Z80) => { // sbc hl,bc
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x43, (z80: Z80) => { // ld (nnnn),bc
    let value: number;
    value = z80.regs.bc;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapED.set(0x7C, (z80: Z80) => { // neg
    const value = z80.regs.a;
    z80.regs.a = 0;
    const diff = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    z80.regs.a = diff;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= z80.sz53Table[z80.regs.a];
    z80.regs.f = f;
});
decodeMapED.set(0x44, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x4C, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x54, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x5C, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x64, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x6C, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x74, decodeMapED.get(0x7C) as OpcodeFunc);
decodeMapED.set(0x7D, (z80: Z80) => { // retn
    z80.regs.iff1 = z80.regs.iff2;
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapED.set(0x45, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x55, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x5D, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x65, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x6D, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x75, decodeMapED.get(0x7D) as OpcodeFunc);
decodeMapED.set(0x6E, (z80: Z80) => { // im 0
    z80.regs.im = 0;
});
decodeMapED.set(0x46, decodeMapED.get(0x6E) as OpcodeFunc);
decodeMapED.set(0x4E, decodeMapED.get(0x6E) as OpcodeFunc);
decodeMapED.set(0x66, decodeMapED.get(0x6E) as OpcodeFunc);
decodeMapED.set(0x47, (z80: Z80) => { // ld i,a
    let value: number;
    value = z80.regs.a;
    z80.incTStateCount(1);
    z80.regs.i = value;
});
decodeMapED.set(0x48, (z80: Z80) => { // in c,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.c = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.c];
});
decodeMapED.set(0x49, (z80: Z80) => { // out (c),c
    z80.writePort(z80.regs.bc, z80.regs.c);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x4A, (z80: Z80) => { // adc hl,bc
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x4B, (z80: Z80) => { // ld bc,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.bc = value;
});
decodeMapED.set(0x4D, (z80: Z80) => { // reti
    z80.regs.iff1 = z80.regs.iff2;
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapED.set(0x4F, (z80: Z80) => { // ld r,a
    let value: number;
    value = z80.regs.a;
    z80.incTStateCount(1);
    z80.regs.r = value;
});
decodeMapED.set(0x50, (z80: Z80) => { // in d,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.d = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.d];
});
decodeMapED.set(0x51, (z80: Z80) => { // out (c),d
    z80.writePort(z80.regs.bc, z80.regs.d);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x52, (z80: Z80) => { // sbc hl,de
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x53, (z80: Z80) => { // ld (nnnn),de
    let value: number;
    value = z80.regs.de;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapED.set(0x76, (z80: Z80) => { // im 1
    z80.regs.im = 1;
});
decodeMapED.set(0x56, decodeMapED.get(0x76) as OpcodeFunc);
decodeMapED.set(0x57, (z80: Z80) => { // ld a,i
    let value: number;
    value = z80.regs.i;
    z80.incTStateCount(1);
    z80.regs.a = value;
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53Table[z80.regs.a] | (z80.regs.iff2 ? Flag.V : 0);
});
decodeMapED.set(0x58, (z80: Z80) => { // in e,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.e = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.e];
});
decodeMapED.set(0x59, (z80: Z80) => { // out (c),e
    z80.writePort(z80.regs.bc, z80.regs.e);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x5A, (z80: Z80) => { // adc hl,de
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x5B, (z80: Z80) => { // ld de,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.de = value;
});
decodeMapED.set(0x7E, (z80: Z80) => { // im 2
    z80.regs.im = 2;
});
decodeMapED.set(0x5E, decodeMapED.get(0x7E) as OpcodeFunc);
decodeMapED.set(0x5F, (z80: Z80) => { // ld a,r
    let value: number;
    value = z80.regs.rCombined;
    z80.incTStateCount(1);
    z80.regs.a = value;
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53Table[z80.regs.a] | (z80.regs.iff2 ? Flag.V : 0);
});
decodeMapED.set(0x60, (z80: Z80) => { // in h,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.h = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.h];
});
decodeMapED.set(0x61, (z80: Z80) => { // out (c),h
    z80.writePort(z80.regs.bc, z80.regs.h);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x62, (z80: Z80) => { // sbc hl,hl
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x63, (z80: Z80) => { // ld (nnnn),hl
    let value: number;
    value = z80.regs.hl;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapED.set(0x67, (z80: Z80) => { // rrd
    const tmp = z80.readByte(z80.regs.hl);
    z80.incTStateCount(4);
    z80.writeByte(z80.regs.hl, ((z80.regs.a << 4) | (tmp >> 4)) & 0xFF);
    z80.regs.a = (z80.regs.a & 0xF0) | (tmp & 0x0F);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.a];
    z80.regs.memptr = inc16(z80.regs.hl);
});
decodeMapED.set(0x68, (z80: Z80) => { // in l,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.l = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.l];
});
decodeMapED.set(0x69, (z80: Z80) => { // out (c),l
    z80.writePort(z80.regs.bc, z80.regs.l);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x6A, (z80: Z80) => { // adc hl,hl
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x6B, (z80: Z80) => { // ld hl,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.hl = value;
});
decodeMapED.set(0x6F, (z80: Z80) => { // rld
    const tmp = z80.readByte(z80.regs.hl);
    z80.incTStateCount(4);
    z80.writeByte(z80.regs.hl, ((tmp << 4) | (z80.regs.a & 0x0F)) & 0xFF);
    z80.regs.a = (z80.regs.a & 0xF0) | (tmp >> 4);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.a];
    z80.regs.memptr = inc16(z80.regs.hl);
});
decodeMapED.set(0x70, (z80: Z80) => { // in f,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.f = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.f];
});
decodeMapED.set(0x71, (z80: Z80) => { // out (c),0
    z80.writePort(z80.regs.bc, 0x00);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x72, (z80: Z80) => { // sbc hl,sp
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x73, (z80: Z80) => { // ld (nnnn),sp
    let value: number;
    value = z80.regs.sp;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapED.set(0x78, (z80: Z80) => { // in a,(c)
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.a = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.a];
});
decodeMapED.set(0x79, (z80: Z80) => { // out (c),a
    z80.writePort(z80.regs.bc, z80.regs.a);
    z80.regs.memptr = inc16(z80.regs.bc);
});
decodeMapED.set(0x7A, (z80: Z80) => { // adc hl,sp
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
                   ((value & 0x8800) >> 10) |
                   ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
});
decodeMapED.set(0x7B, (z80: Z80) => { // ld sp,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.sp = value;
});
decodeMapED.set(0xA0, (z80: Z80) => { // ldi
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = dec16(z80.regs.bc);
    value = add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
    z80.regs.hl = inc16(z80.regs.hl);
    z80.regs.de = inc16(z80.regs.de);
});
decodeMapED.set(0xA1, (z80: Z80) => { // cpi
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
    if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
    z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
    z80.regs.memptr = inc16(z80.regs.memptr);
    z80.regs.hl = inc16(z80.regs.hl);
});
decodeMapED.set(0xA2, (z80: Z80) => { // ini
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.b = dec8(z80.regs.b);
    const other = inc8(add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    z80.regs.hl = inc16(z80.regs.hl);
});
decodeMapED.set(0xA3, (z80: Z80) => { // outi
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = dec8(z80.regs.b);
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = inc16(z80.regs.hl);
    const other = add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
});
decodeMapED.set(0xA8, (z80: Z80) => { // ldd
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = dec16(z80.regs.bc);
    value = add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
    z80.regs.hl = dec16(z80.regs.hl);
    z80.regs.de = dec16(z80.regs.de);
});
decodeMapED.set(0xA9, (z80: Z80) => { // cpd
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
    if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
    z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
    z80.regs.memptr = dec16(z80.regs.memptr);
    z80.regs.hl = dec16(z80.regs.hl);
});
decodeMapED.set(0xAA, (z80: Z80) => { // ind
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = dec16(z80.regs.bc);
    z80.regs.b = dec8(z80.regs.b);
    const other = dec8(add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    z80.regs.hl = dec16(z80.regs.hl);
});
decodeMapED.set(0xAB, (z80: Z80) => { // outd
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = dec8(z80.regs.b);
    z80.regs.memptr = dec16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = dec16(z80.regs.hl);
    const other = add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
});
decodeMapED.set(0xB0, (z80: Z80) => { // ldir
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = dec16(z80.regs.bc);
    value = add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
    if (z80.regs.bc !== 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
        z80.regs.memptr = add16(z80.regs.pc, 1);
    }
    z80.regs.hl = inc16(z80.regs.hl);
    z80.regs.de = inc16(z80.regs.de);
});
decodeMapED.set(0xB1, (z80: Z80) => { // cpir
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
    if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
    z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
    if ((z80.regs.f & (Flag.V | Flag.Z)) === Flag.V) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
        z80.regs.memptr = add16(z80.regs.pc, 1);
    } else {
        z80.regs.memptr = inc16(z80.regs.memptr);
    }
    z80.regs.hl = inc16(z80.regs.hl);
});
decodeMapED.set(0xB2, (z80: Z80) => { // inir
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.regs.b = dec8(z80.regs.b);
    const other = inc8(add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
    }
    z80.regs.hl = inc16(z80.regs.hl);
});
decodeMapED.set(0xB3, (z80: Z80) => { // otir
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = dec8(z80.regs.b);
    z80.regs.memptr = inc16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = inc16(z80.regs.hl);
    const other = add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
    }
});
decodeMapED.set(0xB8, (z80: Z80) => { // lddr
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = dec16(z80.regs.bc);
    value = add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
    if (z80.regs.bc !== 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
        z80.regs.memptr = add16(z80.regs.pc, 1);
    }
    z80.regs.hl = dec16(z80.regs.hl);
    z80.regs.de = dec16(z80.regs.de);
});
decodeMapED.set(0xB9, (z80: Z80) => { // cpdr
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
    if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
    z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
    if ((z80.regs.f & (Flag.V | Flag.Z)) === Flag.V) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
        z80.regs.memptr = add16(z80.regs.pc, 1);
    } else {
        z80.regs.memptr = dec16(z80.regs.memptr);
    }
    z80.regs.hl = dec16(z80.regs.hl);
});
decodeMapED.set(0xBA, (z80: Z80) => { // indr
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = dec16(z80.regs.bc);
    z80.regs.b = dec8(z80.regs.b);
    const other = dec8(add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
    }
    z80.regs.hl = dec16(z80.regs.hl);
});
decodeMapED.set(0xBB, (z80: Z80) => { // otdr
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = dec8(z80.regs.b);
    z80.regs.memptr = dec16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = dec16(z80.regs.hl);
    const other = add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = add16(z80.regs.pc, -2);
    }
});

const decodeMapFD = new Map<number, OpcodeFunc>();
decodeMapFD.set(0x09, (z80: Z80) => { // add iy,bc
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x19, (z80: Z80) => { // add iy,de
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x21, (z80: Z80) => { // ld iy,nnnn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    value = word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.iy = value;
});
decodeMapFD.set(0x22, (z80: Z80) => { // ld (nnnn),iy
    let value: number;
    value = z80.regs.iy;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.writeByte(addr, lo(value));
    addr = inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, hi(value));
});
decodeMapFD.set(0x23, (z80: Z80) => { // inc iy
    let value: number;
    value = z80.regs.iy;
    const oldValue = value;
    z80.incTStateCount(2);
    value = inc16(value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x24, (z80: Z80) => { // inc iyh
    let value: number;
    value = z80.regs.iyh;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.iyh = value;
});
decodeMapFD.set(0x25, (z80: Z80) => { // dec iyh
    let value: number;
    value = z80.regs.iyh;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.iyh = value;
});
decodeMapFD.set(0x26, (z80: Z80) => { // ld iyh,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.iyh = value;
});
decodeMapFD.set(0x29, (z80: Z80) => { // add iy,iy
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.iy;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x2A, (z80: Z80) => { // ld iy,(nnnn)
    let value: number;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    addr = word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = inc16(addr);
    value = word(z80.readByte(z80.regs.memptr), value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x2B, (z80: Z80) => { // dec iy
    let value: number;
    value = z80.regs.iy;
    const oldValue = value;
    z80.incTStateCount(2);
    value = dec16(value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x2C, (z80: Z80) => { // inc iyl
    let value: number;
    value = z80.regs.iyl;
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.regs.iyl = value;
});
decodeMapFD.set(0x2D, (z80: Z80) => { // dec iyl
    let value: number;
    value = z80.regs.iyl;
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.regs.iyl = value;
});
decodeMapFD.set(0x2E, (z80: Z80) => { // ld iyl,nn
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.iyl = value;
});
decodeMapFD.set(0x34, (z80: Z80) => { // inc (iy+dd)
    let value: number;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.iy, signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = inc8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x80 ? Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x35, (z80: Z80) => { // dec (iy+dd)
    let value: number;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.iy, signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = dec8(value);
    z80.regs.f = (z80.regs.f & Flag.C) | (value === 0x7F ? Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : Flag.H) | Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x36, (z80: Z80) => { // ld (iy+dd),nn
    const dd = z80.readByte(z80.regs.pc);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x39, (z80: Z80) => { // add iy,sp
    let value: number;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                   ((value & 0x0800) >> 10) |
                   ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x44, (z80: Z80) => { // ld b,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.b = value;
});
decodeMapFD.set(0x45, (z80: Z80) => { // ld b,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.b = value;
});
decodeMapFD.set(0x46, (z80: Z80) => { // ld b,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.b = value;
});
decodeMapFD.set(0x4C, (z80: Z80) => { // ld c,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.c = value;
});
decodeMapFD.set(0x4D, (z80: Z80) => { // ld c,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.c = value;
});
decodeMapFD.set(0x4E, (z80: Z80) => { // ld c,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.c = value;
});
decodeMapFD.set(0x54, (z80: Z80) => { // ld d,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.d = value;
});
decodeMapFD.set(0x55, (z80: Z80) => { // ld d,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.d = value;
});
decodeMapFD.set(0x56, (z80: Z80) => { // ld d,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.d = value;
});
decodeMapFD.set(0x5C, (z80: Z80) => { // ld e,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.e = value;
});
decodeMapFD.set(0x5D, (z80: Z80) => { // ld e,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.e = value;
});
decodeMapFD.set(0x5E, (z80: Z80) => { // ld e,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.e = value;
});
decodeMapFD.set(0x60, (z80: Z80) => { // ld iyh,b
    let value: number;
    value = z80.regs.b;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x61, (z80: Z80) => { // ld iyh,c
    let value: number;
    value = z80.regs.c;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x62, (z80: Z80) => { // ld iyh,d
    let value: number;
    value = z80.regs.d;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x63, (z80: Z80) => { // ld iyh,e
    let value: number;
    value = z80.regs.e;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x64, (z80: Z80) => { // ld iyh,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x65, (z80: Z80) => { // ld iyh,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x66, (z80: Z80) => { // ld h,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.h = value;
});
decodeMapFD.set(0x67, (z80: Z80) => { // ld iyh,a
    let value: number;
    value = z80.regs.a;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x68, (z80: Z80) => { // ld iyl,b
    let value: number;
    value = z80.regs.b;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x69, (z80: Z80) => { // ld iyl,c
    let value: number;
    value = z80.regs.c;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6A, (z80: Z80) => { // ld iyl,d
    let value: number;
    value = z80.regs.d;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6B, (z80: Z80) => { // ld iyl,e
    let value: number;
    value = z80.regs.e;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6C, (z80: Z80) => { // ld iyl,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6D, (z80: Z80) => { // ld iyl,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6E, (z80: Z80) => { // ld l,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.l = value;
});
decodeMapFD.set(0x6F, (z80: Z80) => { // ld iyl,a
    let value: number;
    value = z80.regs.a;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x70, (z80: Z80) => { // ld (iy+dd),b
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.b;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x71, (z80: Z80) => { // ld (iy+dd),c
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.c;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x72, (z80: Z80) => { // ld (iy+dd),d
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.d;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x73, (z80: Z80) => { // ld (iy+dd),e
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.e;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x74, (z80: Z80) => { // ld (iy+dd),h
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.h;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x75, (z80: Z80) => { // ld (iy+dd),l
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.l;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x77, (z80: Z80) => { // ld (iy+dd),a
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    let value: number;
    value = z80.regs.a;
    z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x7C, (z80: Z80) => { // ld a,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.a = value;
});
decodeMapFD.set(0x7D, (z80: Z80) => { // ld a,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.a = value;
});
decodeMapFD.set(0x7E, (z80: Z80) => { // ld a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a = value;
});
decodeMapFD.set(0x84, (z80: Z80) => { // add a,iyh
    let value: number;
    value = z80.regs.iyh;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x85, (z80: Z80) => { // add a,iyl
    let value: number;
    value = z80.regs.iyl;
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x86, (z80: Z80) => { // add a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8C, (z80: Z80) => { // adc a,iyh
    let value: number;
    value = z80.regs.iyh;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8D, (z80: Z80) => { // adc a,iyl
    let value: number;
    value = z80.regs.iyl;
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8E, (z80: Z80) => { // adc a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = add16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x94, (z80: Z80) => { // sub a,iyh
    let value: number;
    value = z80.regs.iyh;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x95, (z80: Z80) => { // sub a,iyl
    let value: number;
    value = z80.regs.iyl;
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x96, (z80: Z80) => { // sub a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9C, (z80: Z80) => { // sbc a,iyh
    let value: number;
    value = z80.regs.iyh;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9D, (z80: Z80) => { // sbc a,iyl
    let value: number;
    value = z80.regs.iyl;
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9E, (z80: Z80) => { // sbc a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = sub16(z80.regs.a, value);
    if ((z80.regs.f & Flag.C) !== 0) {
        result = dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0xA4, (z80: Z80) => { // and a,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapFD.set(0xA5, (z80: Z80) => { // and a,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapFD.set(0xA6, (z80: Z80) => { // and a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= Flag.H;
});
decodeMapFD.set(0xAC, (z80: Z80) => { // xor a,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xAD, (z80: Z80) => { // xor a,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xAE, (z80: Z80) => { // xor a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB4, (z80: Z80) => { // or a,iyh
    let value: number;
    value = z80.regs.iyh;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB5, (z80: Z80) => { // or a,iyl
    let value: number;
    value = z80.regs.iyl;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB6, (z80: Z80) => { // or a,(iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xBC, (z80: Z80) => { // cp iyh
    let value: number;
    value = z80.regs.iyh;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapFD.set(0xBD, (z80: Z80) => { // cp iyl
    let value: number;
    value = z80.regs.iyl;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapFD.set(0xBE, (z80: Z80) => { // cp (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
                   ((value & 0x88) >> 2) |
                   ((diff & 0x88) >> 1)) & 0xFF;
    let f = Flag.N;
    if ((diff & 0x100) != 0) f |= Flag.C;
    if (diff == 0) f |= Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (Flag.X3 | Flag.X5);
    f |= diff & Flag.S;
    z80.regs.af = word(z80.regs.a, f);
});
decodeMapFD.set(0xCB, (z80: Z80) => { // shift fdcb
    decodeFDCB(z80);
});
decodeMapFD.set(0xE1, (z80: Z80) => { // pop iy
    z80.regs.iy = z80.popWord();
});
decodeMapFD.set(0xE3, (z80: Z80) => { // ex (sp),iy
    const rightValue = z80.regs.iy;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
    z80.writeByte(z80.regs.sp, lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = word(leftValueH, leftValueL);
    z80.regs.iy = word(leftValueH, leftValueL);
});
decodeMapFD.set(0xE5, (z80: Z80) => { // push iy
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.iy);
});
decodeMapFD.set(0xE9, (z80: Z80) => { // jp iy
    z80.regs.pc = z80.regs.iy;
});
decodeMapFD.set(0xF9, (z80: Z80) => { // ld sp,iy
    let value: number;
    value = z80.regs.iy;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});

const decodeMapFDCB = new Map<number, OpcodeFunc>();
decodeMapFDCB.set(0x00, (z80: Z80) => { // ld b,rlc
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x01, (z80: Z80) => { // ld c,rlc
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x02, (z80: Z80) => { // ld d,rlc
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x03, (z80: Z80) => { // ld e,rlc
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x04, (z80: Z80) => { // ld h,rlc
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x05, (z80: Z80) => { // ld l,rlc
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x06, (z80: Z80) => { // rlc (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x07, (z80: Z80) => { // ld a,rlc
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x08, (z80: Z80) => { // ld b,rrc
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x09, (z80: Z80) => { // ld c,rrc
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x0A, (z80: Z80) => { // ld d,rrc
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x0B, (z80: Z80) => { // ld e,rrc
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x0C, (z80: Z80) => { // ld h,rrc
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x0D, (z80: Z80) => { // ld l,rrc
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x0E, (z80: Z80) => { // rrc (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x0F, (z80: Z80) => { // ld a,rrc
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x10, (z80: Z80) => { // ld b,rl
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x11, (z80: Z80) => { // ld c,rl
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x12, (z80: Z80) => { // ld d,rl
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x13, (z80: Z80) => { // ld e,rl
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x14, (z80: Z80) => { // ld h,rl
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x15, (z80: Z80) => { // ld l,rl
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x16, (z80: Z80) => { // rl (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x17, (z80: Z80) => { // ld a,rl
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x18, (z80: Z80) => { // ld b,rr
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x19, (z80: Z80) => { // ld c,rr
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x1A, (z80: Z80) => { // ld d,rr
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x1B, (z80: Z80) => { // ld e,rr
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x1C, (z80: Z80) => { // ld h,rr
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x1D, (z80: Z80) => { // ld l,rr
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x1E, (z80: Z80) => { // rr (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x1F, (z80: Z80) => { // ld a,rr
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x20, (z80: Z80) => { // ld b,sla
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x21, (z80: Z80) => { // ld c,sla
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x22, (z80: Z80) => { // ld d,sla
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x23, (z80: Z80) => { // ld e,sla
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x24, (z80: Z80) => { // ld h,sla
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x25, (z80: Z80) => { // ld l,sla
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x26, (z80: Z80) => { // sla (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x27, (z80: Z80) => { // ld a,sla
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x28, (z80: Z80) => { // ld b,sra
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x29, (z80: Z80) => { // ld c,sra
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x2A, (z80: Z80) => { // ld d,sra
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x2B, (z80: Z80) => { // ld e,sra
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x2C, (z80: Z80) => { // ld h,sra
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x2D, (z80: Z80) => { // ld l,sra
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x2E, (z80: Z80) => { // sra (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x2F, (z80: Z80) => { // ld a,sra
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x30, (z80: Z80) => { // ld b,sll
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x31, (z80: Z80) => { // ld c,sll
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x32, (z80: Z80) => { // ld d,sll
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x33, (z80: Z80) => { // ld e,sll
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x34, (z80: Z80) => { // ld h,sll
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x35, (z80: Z80) => { // ld l,sll
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x36, (z80: Z80) => { // sll (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x37, (z80: Z80) => { // ld a,sll
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x38, (z80: Z80) => { // ld b,srl
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.b;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x39, (z80: Z80) => { // ld c,srl
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.c;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x3A, (z80: Z80) => { // ld d,srl
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.d;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x3B, (z80: Z80) => { // ld e,srl
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.e;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x3C, (z80: Z80) => { // ld h,srl
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.h;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x3D, (z80: Z80) => { // ld l,srl
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.l;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x3E, (z80: Z80) => { // srl (iy+dd)
    let value: number;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x3F, (z80: Z80) => { // ld a,srl
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value: number;
        value = z80.regs.a;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x47, (z80: Z80) => { // bit 0,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x01) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x40, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x41, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x42, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x43, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x44, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x45, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x46, decodeMapFDCB.get(0x47) as OpcodeFunc);
decodeMapFDCB.set(0x4F, (z80: Z80) => { // bit 1,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x02) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x48, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x49, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x4A, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x4B, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x4C, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x4D, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x4E, decodeMapFDCB.get(0x4F) as OpcodeFunc);
decodeMapFDCB.set(0x57, (z80: Z80) => { // bit 2,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x04) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x50, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x51, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x52, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x53, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x54, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x55, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x56, decodeMapFDCB.get(0x57) as OpcodeFunc);
decodeMapFDCB.set(0x5F, (z80: Z80) => { // bit 3,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x08) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x58, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x59, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x5A, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x5B, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x5C, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x5D, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x5E, decodeMapFDCB.get(0x5F) as OpcodeFunc);
decodeMapFDCB.set(0x67, (z80: Z80) => { // bit 4,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x10) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x60, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x61, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x62, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x63, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x64, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x65, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x66, decodeMapFDCB.get(0x67) as OpcodeFunc);
decodeMapFDCB.set(0x6F, (z80: Z80) => { // bit 5,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x20) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x68, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x69, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x6A, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x6B, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x6C, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x6D, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x6E, decodeMapFDCB.get(0x6F) as OpcodeFunc);
decodeMapFDCB.set(0x77, (z80: Z80) => { // bit 6,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x40) === 0) {
        f |= Flag.P | Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x70, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x71, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x72, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x73, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x74, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x75, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x76, decodeMapFDCB.get(0x77) as OpcodeFunc);
decodeMapFDCB.set(0x7F, (z80: Z80) => { // bit 7,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & Flag.C) | Flag.H | (hiddenValue & (Flag.X3 | Flag.X5));
    if ((value & 0x80) === 0) {
        f |= Flag.P | Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= Flag.S;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x78, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x79, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x7A, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x7B, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x7C, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x7D, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x7E, decodeMapFDCB.get(0x7F) as OpcodeFunc);
decodeMapFDCB.set(0x80, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x81, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x82, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x83, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x84, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x85, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x86, (z80: Z80) => { // res 0,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFE);
});
decodeMapFDCB.set(0x87, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x88, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x89, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x8A, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x8B, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x8C, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x8D, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x8E, (z80: Z80) => { // res 1,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFD);
});
decodeMapFDCB.set(0x8F, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x90, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x91, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x92, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x93, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x94, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x95, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x96, (z80: Z80) => { // res 2,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFB);
});
decodeMapFDCB.set(0x97, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x98, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x99, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x9A, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x9B, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x9C, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x9D, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x9E, (z80: Z80) => { // res 3,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xF7);
});
decodeMapFDCB.set(0x9F, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xA0, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xA1, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xA2, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xA3, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xA4, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xA5, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xA6, (z80: Z80) => { // res 4,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xEF);
});
decodeMapFDCB.set(0xA7, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xA8, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xA9, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xAA, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xAB, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xAC, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xAD, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xAE, (z80: Z80) => { // res 5,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xDF);
});
decodeMapFDCB.set(0xAF, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xB0, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xB1, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xB2, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xB3, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xB4, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xB5, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xB6, (z80: Z80) => { // res 6,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xBF);
});
decodeMapFDCB.set(0xB7, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xB8, (z80: Z80) => { // ld b,res
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xB9, (z80: Z80) => { // ld c,res
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xBA, (z80: Z80) => { // ld d,res
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xBB, (z80: Z80) => { // ld e,res
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xBC, (z80: Z80) => { // ld h,res
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xBD, (z80: Z80) => { // ld l,res
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xBE, (z80: Z80) => { // res 7,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0x7F);
});
decodeMapFDCB.set(0xBF, (z80: Z80) => { // ld a,res
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xC0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xC1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xC2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xC3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xC4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xC5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xC6, (z80: Z80) => { // set 0,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x01);
});
decodeMapFDCB.set(0xC7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xC8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xC9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xCA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xCB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xCC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xCD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xCE, (z80: Z80) => { // set 1,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x02);
});
decodeMapFDCB.set(0xCF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xD0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xD1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xD2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xD3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xD4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xD5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xD6, (z80: Z80) => { // set 2,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x04);
});
decodeMapFDCB.set(0xD7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xD8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xD9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xDA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xDB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xDC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xDD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xDE, (z80: Z80) => { // set 3,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x08);
});
decodeMapFDCB.set(0xDF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xE0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xE1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xE2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xE3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xE4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xE5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xE6, (z80: Z80) => { // set 4,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x10);
});
decodeMapFDCB.set(0xE7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xE8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xE9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xEA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xEB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xEC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xED, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xEE, (z80: Z80) => { // set 5,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x20);
});
decodeMapFDCB.set(0xEF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xF0, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xF1, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xF2, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xF3, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xF4, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xF5, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xF6, (z80: Z80) => { // set 6,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x40);
});
decodeMapFDCB.set(0xF7, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xF8, (z80: Z80) => { // ld b,set
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xF9, (z80: Z80) => { // ld c,set
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xFA, (z80: Z80) => { // ld d,set
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xFB, (z80: Z80) => { // ld e,set
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xFC, (z80: Z80) => { // ld h,set
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xFD, (z80: Z80) => { // ld l,set
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xFE, (z80: Z80) => { // set 7,(iy+dd)
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x80);
});
decodeMapFDCB.set(0xFF, (z80: Z80) => { // ld a,set
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});

/**
 * Fetch an instruction for decode.
 */
function fetchInstruction(z80: Z80): number {
    z80.incTStateCount(4);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.regs.pc = (z80.regs.pc + 1) & 0xFFFF;
    z80.regs.r = (z80.regs.r + 1) & 0xFF;

    return inst;
}

/**
 * Decode the "CB" prefix (bit instructions).
 */
function decodeCB(z80: Z80): void {
    const inst = fetchInstruction(z80);
    const func = decodeMapCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in CB: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the "DD" prefix (IX instructions).
 */
function decodeDD(z80: Z80): void {
    const inst = fetchInstruction(z80);
    const func = decodeMapDD.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in DD: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the "DDCB" prefix (IX bit instructions).
 */
function decodeDDCB(z80: Z80): void {
    z80.incTStateCount(3);
    const offset = z80.readByteInternal(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.ix, signedByte(offset));
    z80.regs.pc = inc16(z80.regs.pc);
    z80.incTStateCount(3);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = inc16(z80.regs.pc);

    const func = decodeMapDDCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in DDCB: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the "ED" prefix (extended instructions).
 */
function decodeED(z80: Z80): void {
    const inst = fetchInstruction(z80);
    const func = decodeMapED.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in ED: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the "FD" prefix (IY instructions).
 */
function decodeFD(z80: Z80): void {
    const inst = fetchInstruction(z80);
    const func = decodeMapFD.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in FD: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the "FDCB" prefix (IY bit instructions).
 */
function decodeFDCB(z80: Z80): void {
    z80.incTStateCount(3);
    const offset = z80.readByteInternal(z80.regs.pc);
    z80.regs.memptr = add16(z80.regs.iy, signedByte(offset));
    z80.regs.pc = inc16(z80.regs.pc);
    z80.incTStateCount(3);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = inc16(z80.regs.pc);

    const func = decodeMapFDCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in FDCB: " + toHex(inst, 2));
    } else {
        func(z80);
    }
}

/**
 * Decode the base (un-prefixed) instructions.
 */
export function decode(z80: Z80): void {
    const inst = fetchInstruction(z80);
    const func = decodeMapBASE.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode " + toHex(inst, 2));
    } else {
        func(z80);
    }
}
