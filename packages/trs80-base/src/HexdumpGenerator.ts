import {toHex, toHexByte} from "z80-base";
import {ProgramAnnotation} from "./ProgramAnnotation.js";

// Number of bytes per row.
const STRIDE = 16;

// Unicode for a vertical ellipsis.
const VERTICAL_ELLIPSIS = 0x22EE;

/**
 * Class names used in spans.
 */
export type HexdumpClass =
    // hex address of a row.
    "address" |
    // hex data.
    "hex" |
    // plain ASCII data.
    "ascii" |
    // ASCII data but not printable (e.g., control character).
    "ascii-unprintable" |
    // text annotations on the right side.
    "annotation" |
    // mixin class for data that's outside the current line's annotation. Should
    // be displayed dimly or not at all.
    "outside-annotation" |
    // blank space.
    "space";

/**
 * Returns whether two string arrays are the same.
 *
 * Lodash has isEqual(), but it adds about 15 kB after minimization! (It's a deep comparison
 * that has to deal with all sorts of data types.)
 */
export function isSameStringArray(a: string[], b: string[]): boolean {
    return a.length === b.length && a.every((value, index) => value === b[index]);
}

/**
 * Compare two parts of an array for equality.
 */
function segmentsEqual(binary: Uint8Array, start1: number, start2: number, length: number): boolean {
    while (length-- > 0) {
        if (binary[start1++] !== binary[start2++]) {
            return false;
        }
    }

    return true;
}

/**
 * Count consecutive bytes that are around "addr".
 */
function countConsecutive(binary: Uint8Array, addr: number) {
    const value = binary[addr];

    let startAddr = addr;
    while (startAddr > 0 && binary[startAddr - 1] === value) {
        startAddr--;
    }

    while (addr < binary.length - 1 && binary[addr + 1] === value) {
        addr++;
    }

    return addr - startAddr + 1;
}

/**
 * Whether this segment is made up of the same value.
 */
function allSameByte(binary: Uint8Array, addr: number, length: number): boolean {
    for (let i = 1; i < length; i++) {
        if (binary[addr + i] !== binary[addr]) {
            return false;
        }
    }

    return true;
}

/**
 * Options for generating a hexdump.
 */
export interface HexdumpOptions {
    // Whether to collapse duplicate lines. Defaults to true.
    collapse?: boolean;

    // Whether to show the end address on a separate line. Defaults to true.
    showLastAddress?: boolean;
}

/**
 * Span of text generated by the hexdump.
 */
export class HexdumpSpan {
    public readonly text: string;
    public readonly address: number | undefined;
    public readonly classes: HexdumpClass[];

    constructor(text: string, address: number | undefined, ...classes: HexdumpClass[]) {
        this.text = text;
        this.address = address;
        this.classes = classes;
    }

    /**
     * Whether this is a space span (has the "space" class).
     */
    public isSpace(): boolean {
        return this.classes.indexOf("space") >= 0;
    }
}

/**
 * A line generated by the hexdump. Contains spans, each with its own set of classes.
 */
export class HexdumpLine {
    public readonly spans: HexdumpSpan[] = [];

    /**
     * Add a span to the line.
     */
    public add(text: string, address: number | undefined, ...classes: HexdumpClass[]): void {
        this.spans.push(new HexdumpSpan(text, address, ...classes));
    }

    public length(): number {
        let length = 0;

        for (const span of this.spans) {
            length += span.text.length;
        }

        return length;
    }

    /**
     * Collapse consecutive spans that have the same classes and address.
     *
     * @param ignoreAddress whether to ignore the address when collapsing. Spans will have the address
     * of the first collapsed span.
     * @param collapseSpaces whether to collapse spans with space classes into their neighbors.
     */
    public collapse(ignoreAddress: boolean, collapseSpaces: boolean): HexdumpLine {
        const line = new HexdumpLine();

        const shouldCollapse = (i1: number, i2: number): boolean => {
            const s1 = this.spans[i1];
            const s2 = this.spans[i2];

            if (collapseSpaces && (s1.isSpace() || s2.isSpace())) {
                return true;
            }

            return isSameStringArray(s1.classes, s2.classes) &&
                (ignoreAddress || s1.address === s2.address);
        };

        for (let first = 0; first < this.spans.length; first++) {
            let last = first;
            let firstNonSpace = undefined;

            // The first non-space is the one we're comparing classes for.
            while (last < this.spans.length - 1 && shouldCollapse(firstNonSpace ?? first, last + 1)) {
                last += 1;
                if (collapseSpaces && firstNonSpace === undefined && !this.spans[last].isSpace()) {
                    firstNonSpace = last;
                }
            }

            if (first === last) {
                line.spans.push(this.spans[first]);
            } else {
                const firstUsefulSpan = this.spans[firstNonSpace ?? first];
                const text = this.spans.slice(first, last + 1).map(span => span.text).join("");
                line.add(text, firstUsefulSpan.address, ...firstUsefulSpan.classes);
            }

            first = last;
        }

        return line;
    }
}

/**
 * Generates a hexdump for the given binary.
 */
export class HexdumpGenerator {
    private readonly binary: Uint8Array;
    private readonly annotations: ProgramAnnotation[];
    private readonly options: HexdumpOptions;

    public constructor(binary: Uint8Array, annotations: ProgramAnnotation[], options?: HexdumpOptions) {
        this.binary = binary;
        this.annotations = annotations;
        this.options = options ?? {};
    }

    /**
     * Generate all HTML elements for this binary.
     */
    public *generate(): Generator<HexdumpLine, void, void> {
        const binary = this.binary;

        const [addrDigits, addrSpaces] = this.computeAddressSize();

        // Sort in case they were generated out of order.
        this.annotations.sort((a, b) => a.begin - b.begin);

        let lastAnnotation: ProgramAnnotation | undefined = undefined;
        for (const annotation of this.annotations) {
            if (lastAnnotation !== undefined && lastAnnotation.end < annotation.begin) {
                yield* this.generateAnnotation(new ProgramAnnotation("", lastAnnotation.end, annotation.begin));
            }
            // Make sure there are no overlapping annotations.
            if (lastAnnotation === undefined || lastAnnotation.end <= annotation.begin) {
                yield* this.generateAnnotation(annotation);
            }
            lastAnnotation = annotation;
        }
        const lastAnnotationEnd = lastAnnotation !== undefined ? lastAnnotation.end : 0;
        if (lastAnnotationEnd < binary.length) {
            yield* this.generateAnnotation(new ProgramAnnotation("", lastAnnotationEnd, binary.length));
        }

        if (this.options.showLastAddress ?? true) {
            // Final address to show where file ends.
            const finalLine = new HexdumpLine();
            finalLine.add(toHex(binary.length, addrDigits), binary.length, "address");
            yield finalLine;
        }
    }

    /**
     * Generate all the lines for an annotation.
     * @param annotation the annotation to generate.
     */
    private *generateAnnotation(annotation: ProgramAnnotation): Generator<HexdumpLine, void, void> {
        const binary = this.binary;

        const [addrDigits, addrSpaces] = this.computeAddressSize();

        const beginAddr = Math.floor(annotation.begin/STRIDE)*STRIDE;
        const endAddr = Math.min(Math.ceil(annotation.end/STRIDE)*STRIDE, binary.length);
        let lastAddr: number | undefined = undefined;
        for (let addr = beginAddr; addr < endAddr; addr += STRIDE) {
            if ((this.options.collapse ?? true) && lastAddr !== undefined &&
                binary.length - addr >= STRIDE && segmentsEqual(binary, lastAddr, addr, STRIDE)) {

                // Collapsed section. See if we want to print the text for it this time.
                if (addr === lastAddr + STRIDE) {
                    const line = new HexdumpLine();

                    if (allSameByte(binary, addr, STRIDE)) {
                        // Lots of the same byte repeated. Say many there are.
                        const count = countConsecutive(binary, addr);
                        line.add(addrSpaces + "   ... ", undefined, "address");
                        line.add(count.toString(), undefined, "ascii");
                        line.add(" (", undefined, "address");
                        line.add("0x" + count.toString(16).toUpperCase(), undefined, "ascii");
                        line.add(") consecutive bytes of ", undefined, "address");
                        line.add("0x" + toHexByte(binary[addr]), undefined, "hex");
                        line.add(" ...", undefined, "address");
                    } else {
                        // A repeating pattern, but not all the same byte. Say how many times repeated.
                        let count = 1;
                        for (let otherAddr = addr + STRIDE; otherAddr <= binary.length - STRIDE; otherAddr += STRIDE) {
                            if (segmentsEqual(binary, lastAddr, otherAddr, STRIDE)) {
                                count += 1;
                            } else {
                                break;
                            }
                        }
                        line.add(addrSpaces + "  ... ", undefined, "address");
                        line.add(count.toString(), undefined, "ascii");
                        const plural = count === 1 ? "" : "s";
                        line.add(` repetition${plural} of previous row ...`, undefined, "address");
                    }

                    // Draw vertical ellipsis.
                    if (annotation.text !== "" && addr !== beginAddr) {
                        const width = addrDigits + STRIDE*4 + 10;
                        const label = String.fromCodePoint(VERTICAL_ELLIPSIS).padStart(width - line.length(), " ");
                        line.add(label, undefined, "annotation");
                    }

                    yield line;
                }
            } else {
                // Non-collapsed row.
                lastAddr = addr;

                let label: string = "";
                if (annotation.text !== "") {
                    if (addr === beginAddr) {
                        label = annotation.text;
                    } else {
                        // Vertical ellipsis.
                        label = "  " + String.fromCodePoint(VERTICAL_ELLIPSIS);
                    }
                }

                yield this.generateRow(addr, addrDigits, annotation.begin, annotation.end, label);
            }
        }
    }

    /**
     * Generates a single row of hex and ASCII.
     * @param addr address for the line.
     * @param addrDigits the number of digits in the address.
     * @param beginAddr the first address of this annotation (inclusive).
     * @param endAddr this last address of this annotation (exclusive).
     * @param label the label to show on this row.
     * @return the created row.
     */
    private generateRow(addr: number, addrDigits: number,
                        beginAddr: number, endAddr: number, label: string): HexdumpLine {

        const binary = this.binary;

        const line = new HexdumpLine();
        const cssClass: HexdumpClass[] = ["address"];
        if (addr < beginAddr) {
            cssClass.push("outside-annotation");
        }
        line.add(toHex(addr, addrDigits), addr, ...cssClass);
        line.add("  ", undefined, "space");

        // Hex.
        let subAddr: number;
        for (subAddr = addr; subAddr < binary.length && subAddr < addr + STRIDE; subAddr++) {
            const cssClass: HexdumpClass[] = ["hex"];
            if (subAddr < beginAddr || subAddr >= endAddr) {
                cssClass.push("outside-annotation");
            }
            const halfWay = subAddr == addr + STRIDE/2 - 1;
            line.add(toHexByte(binary[subAddr]), subAddr, ...cssClass);
            line.add(halfWay ? "  " : " ", undefined, "space");
        }
        line.add("".padStart((addr + STRIDE - subAddr) * 3 + 2, " "), undefined, "space");

        // ASCII.
        for (subAddr = addr; subAddr < binary.length && subAddr < addr + STRIDE; subAddr++) {
            const c = binary[subAddr];
            const cssClass: HexdumpClass[] = ["hex"];
            let char;
            if (c >= 32 && c < 127) {
                cssClass.push("ascii");
                char = String.fromCharCode(c);
            } else {
                cssClass.push("ascii-unprintable");
                char = ".";
            }
            if (subAddr < beginAddr || subAddr >= endAddr) {
                cssClass.push("outside-annotation");
            }
            line.add(char, subAddr, ...cssClass);
        }
        if (label !== "") {
            line.add("".padStart(addr + STRIDE - subAddr + 2, " ") + label, undefined, "annotation");
        }

        return line;
    }

    /**
     * Computes the number of hex digits in the displayed address, and the spaces this represents.
     */
    private computeAddressSize(): [number, string] {
        // Figure out the number of digits in the address: 4 or 6.
        const addrDigits = this.binary.length < (2 << 16) ? 4 : 6;
        const addrSpaces = "".padStart(addrDigits, " ");

        return [addrDigits, addrSpaces];
    }
}
